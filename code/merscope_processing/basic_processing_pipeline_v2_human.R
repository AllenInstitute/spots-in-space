
# load necessary libraries
library(data.table)
library(ggplot2)
library(cowplot)
library(vioplot)
library(readxl)
library(dplyr)
library(tidyr)
library(rearrr)
library(anndata)
library(matrixStats)
library(Matrix)

############################### setup environment ###############################

options(stringsAsFactors = FALSE)
options(scipen=999)

# first step is to define the location of the data
section <- "1170797659"
inputFolder <- "~/surveyNAS05/scratch/human/AD_MTG/resegmented_data_copies/"
outputFolder <- "~/surveyNAS05/scratch/human/AD_MTG/resegmented_data_copies/"

# next I load an excel file with some metadata (this will be eventually replaced by an output of the power BI app)
run_tracker <- read_xlsx("~/surveyNAS05/scratch/human/AD_MTG/reference_data/MERSCOPE_human_imaging_tracker.xlsx", sheet=1)

# I select the correct row by searching for the section name
idx <- which(run_tracker$`Run Name` == section)
# for this example I only extract the image rotation to have the section displayed properly
#image_rotation <- run_tracker$`Image Rotation`[idx] || 0

# here I set some basic filtering criteria. 
# These are mainly based on visual inspection of the data after previous rounds or processing
min_vol <- 100
max_vol <- 3000
min_genes <- 15
max_genes <- 300
min_counts <- 100
max_counts <- 2500

############################## load data ###########################
# Load the cell by gene table generated by cellpose
cbg <- data.table::fread(paste0(inputFolder,section,"/region_0/cellpose_cyto2_nuclei_mask4/cellpose-cell-by-gene.csv"), 
                                  header=TRUE,
                                  stringsAsFactors=FALSE,
                                  check.names = FALSE
)
# turn the first row (containing cell id's) to rownames
cbg <- tibble::column_to_rownames(cbg,var="cell") 
# extract all blanks from cell by gene table
blanks <- dplyr::select(cbg,contains("Blank"))
# remove all blanks from cell by gene table
cbg <- dplyr::select(cbg,-contains("Blank"))

# load metadata for associated cell by gene table
metadata <- data.table::fread(paste0(inputFolder,section,"/region_0/cellpose_cyto2_nuclei_mask4/cellpose_metadata.csv"), 
                                       header=TRUE,
                                       stringsAsFactors=FALSE,
                                       check.names = FALSE
)
# turn the first row (containing cell id's) to rownames
metadata <- tibble::column_to_rownames(metadata,var="id") 
# order rows in metadata file to match the one in cell by gene table
metadata <- metadata[match(rownames(cbg),rownames(metadata)),]

############################## rotate images ##############################3
# turn rownames into columns (necessary for next function wo work properly)
#metadata <- metadata %>% tibble::rownames_to_column(var = "sample_id")
# adjust image orientation
# metadata <- metadata %>%
#   rotate_2d(
#     x_col = "center_x",
#     y_col = "center_y",
#    degrees = image_rotation,
#     origin_fn = centroid
#   )
# rename new column names
#colnames(metadata)[11:14] <- c("corrected_x","corrected_y","origin","rotation")
# convert origin to character (otherwise it can't be saved as h5ad later)
#metadata$origin <- as.character(metadata$origin)
# turn the first row (containing cell id's) to rownames
# metadata <- tibble::column_to_rownames(metadata,var = "sample_id")
# order rows in metadata and blank file to match the one in cell by gene table
#metadata <- metadata[match(rownames(cbg),rownames(metadata)),]
#blanks <- blanks[match(rownames(cbg),rownames(blanks)),]

################### add some basic metadata #######################
# calaculate how many different genes are detected in each cell
metadata$genes_detected <- rowSums(cbg!=0)
# calaculate how many mRNA spots are detected per cell
metadata$total_reads <- rowSums(cbg)
# calaculate how many blank spots are detected per cell
metadata$total_blanks <- rowSums(blanks)
# calaculate density of spots per cell
metadata$spot_density <- (metadata$total_reads/metadata$volume)*1000
# calculate the highest number a balnk spot was detected
metadata$max_blank_count <- rowMaxs(as.matrix(blanks[,c(-1)]))
# calculate how many different blanks are detected per cell
metadata$blanks_detected <- rowSums(blanks!=0)

######################## filter data ###############################
# add column to metadata that indicates cell quality as high or low
metadata <- metadata %>% 
  mutate(cell_qc = if_else(genes_detected < min_genes | 
                             total_reads < min_counts| 
                             volume < min_vol |
                             volume > max_vol |
                             genes_detected > max_genes |
                             total_reads > max_counts, 
                           "Low","High"))

############################### filter cellxgene table #########################
# combine blanks and cbg back together
cbg <- merge(cbg,blanks,by=0)
# turn the first row (containing cell id's) to rownames
cbg <- tibble::column_to_rownames(cbg,var="Row.names")
# order rows in metadata file to match the one in cell by gene table
cbg <- cbg[match(rownames(metadata),rownames(cbg)),]

# filter metadata to only contain high quality cells
metadata_subset <- metadata %>% dplyr::filter(cell_qc == "High") 
# filter cell by gene to only contain high quality cells
to_keep_org <- intersect(rownames(cbg),rownames(metadata_subset))
cbg_filtered <- cbg[to_keep_org,]
cbg_filtered <- as.matrix(cbg_filtered)
# normalize cells by volume (counts per Âµm)
cbg_cpum <- (cbg_filtered / metadata_subset$volume*1000)
# log normalize data
cbg_norm <- log2(cbg_cpum+1)
# order rows between cell by genes tables and metadata to match each other
cbg_norm <- cbg_norm[match(rownames(cbg_cpum),rownames(cbg_norm)),]
cbg_filtered <- cbg_filtered[match(rownames(cbg_cpum),rownames(cbg_filtered)),]
# save log normalized file to .rda for later mapping
save(cbg_norm, file=paste0(outputFolder,section,"/norm.dat.rda"))

########## create coordinates matrix to display in cirro and squidpy ########
# subset coordinates with only good cells for cirro
coordinates_cirro <- metadata %>% 
  dplyr::filter(cell_qc == "High")# %>% 
#  dplyr::select(corrected_x,corrected_y)
# subset coordinates with only good cells for squidpy/scanpy
coordinates_sq <- metadata %>% 
  dplyr::filter(cell_qc == "High") #%>% 
#  dplyr::select(corrected_x,corrected_y)

# invert y-axis
#coordinates_cirro$corrected_y = -(coordinates_cirro$corrected_y - mean(coordinates_cirro$corrected_y))
#coordinates_cirro$corrected_x = coordinates_cirro$corrected_x - min(coordinates_cirro$corrected_x)

############### convert to anndata file and save #########################

ad <- AnnData(
  X = cbg_cpum,
  layers = list(
    raw = cbg_filtered,
    log2p = cbg_norm
  ),
  obs = metadata_subset,
  obsm = list(
    spatial = as.matrix(coordinates_sq),
    spatial_cirro = as.matrix(coordinates_cirro)
  )
)

write_h5ad(ad,paste0(outputFolder,section,"/",section,".h5ad"))
# 
# # empty environment to save RAM during mapping
# rm(list=ls())
# 
# # load gene names of good genes
# #MFISH500 <- read.csv("/allen/programs/celltypes/workgroups/rnaseqanalysis/yzizhen/joint_analysis/forebrain_new/Vizgen/AIBS_MERFISH_500genes_with_notes.csv")
# #MFISHgenes = MFISH500 %>% filter(targetable & sufficient_target_regions) %>% select(X.1)
# # read count matrix for human MTG rnaseq data
# MFISHgenes <-
#   anndata::read_h5ad(
#     "/home/imaging_mfish/surveyNAS05/scratch/human/AD_MTG/results/misc_H5ad_files/final.2022-04-14_GENE_PANEL_SUBSET_ref_only.h5ad"
#   )
# 
# # load back anndata file
# section <- "1195927756_new_mapping"
# inputFolder <- "~/surveyNAS05/scratch/human/AD_MTG/eg_knn_test/"
# outputFolder <- "~/surveyNAS05/scratch/human/AD_MTG/eg_knn_test/"
# 
# ad <- read_h5ad(paste0(outputFolder,section,"/",section,".h5ad"))
# 
# # extract log normalized data
# qdat = t(ad$layers['log2p']) #what vizgen.dat was in original mapping
# common = intersect(rownames(qdat), rownames(MFISHgenes))
# norm.dat <- qdat[common,]
# 
# # remove unnecessary files to save memory
# rm(ad,qdat)
# 
# source("/allen/programs/celltypes/workgroups/rnaseqanalysis/changkyul/Mapping_On_Taxonomy/hmapping/hmapping_util.R")
# mapped = run_mapping_on_taxonomy(
#   norm.dat,           # query data
#   Taxonomy="scANVI",      
#   TaxFN = "",                   #human tax not prebuilt so need to load in
#   prefix="MFISH",                # prefix for your data platform (SS, 10X_cells_v2, 10X_cells_v3, 
#   #                                10X_nuclei_v3, MFISH)
#   prebuild=TRUE,                 # use it if the taxonomy training template is available 
#   # for your data platform
#   newbuild=TRUE,                 # TRUE marker selection from available genes 
#   # FALSE take intersection (available genes, marker genes)
#   mapping.method='flat',    # 'flat','hierarchy'
#   mc.cores=20,                   # lower this to 5 if the run fails due to the memory
#   iter=20,
#   blocksize=50000)
# 
# save(mapped,file=paste0(outputFolder,section,"/mapped_hkn.rda"))
