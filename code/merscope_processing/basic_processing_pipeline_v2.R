
# load necessary libraries
library(data.table)
library(ggplot2)
library(cowplot)
library(vioplot)
library(readxl)
library(dplyr)
library(tidyr)
library(rearrr)
library(anndata)
library(matrixStats)
library(Matrix)

############################### setup environment ###############################

options(stringsAsFactors = FALSE)
options(scipen=999)

# first step is to define the location of the data
section <- "202202221441_60988207_VMSC01001"
inputFolder <- "/allen/programs/celltypes/workgroups/rnaseqanalysis/mFISH/michaelkunst/test_data/merfish_output/"
outputFolder <- "/allen/programs/celltypes/workgroups/rnaseqanalysis/mFISH/michaelkunst/test_data/merfish_processed/"

# next I load an excel file with some metadata (this will be eventually replaced by an output of the power BI app)
run_tracker <- read_xlsx("/allen/programs/celltypes/workgroups/rnaseqanalysis/mFISH/michaelkunst/MERSCOPES/MERSCOPE Atlas Run tracker_220315.xlsx", sheet=1)

# I select the correct row by searching for the section name
idx <- which(run_tracker$`Run Name` == section)
# for this example I only extract the image rotation to have the section displayed properly
image_rotation <- run_tracker$`Image Rotation`[idx]

# I also need to load a file that renames gene names that are different between vizgen and our nomenclature
gene_name_conversion <- read.csv("/allen/programs/celltypes/workgroups/rnaseqanalysis/mFISH/michaelkunst/MERSCOPES/mouse/InitialGeneList_AIBS_03_28_22.csv",
                                 header = TRUE,
                                 check.names = FALSE)
# here I set some basic filtering criteria. 
# These are mainly based on visual inspection of the data after previous rounds or processing
min_vol <- 100
max_vol <- 3000
min_genes <- 15
max_genes <- 300
min_counts <- 100
max_counts <- 2500

############################## load data ###########################
# Load the cell by gene table generated by cellpose
cbg <- data.table::fread(paste0(inputFolder,section,"/region_0/cellpose_cyto2_nuclei/cellpose-cell-by-gene.csv"), 
                                  header=TRUE,
                                  stringsAsFactors=FALSE,
                                  check.names = FALSE
)
# turn the first row (containing cell id's) to rownames
cbg <- tibble::column_to_rownames(cbg,var="cell") 
# extract all blanks from cell by gene table
blanks <- dplyr::select(cbg,contains("Blank"))
# remove all blanks from cell by gene table
cbg <- dplyr::select(cbg,-contains("Blank"))

# load metadata for associated cell by gene table
metadata <- data.table::fread(paste0(inputFolder,section,"/region_0/cellpose_cyto2_nuclei/cellpose_metadata.csv"), 
                                       header=TRUE,
                                       stringsAsFactors=FALSE,
                                       check.names = FALSE
)
# turn the first row (containing cell id's) to rownames
metadata <- tibble::column_to_rownames(metadata,var="id") 
# order rows in metadata file to match the one in cell by gene table
metadata <- metadata[match(rownames(cbg),rownames(metadata)),]

############################## rotate images ##############################3
# turn rownames into columns (necessary for next function wo work properly)
metadata <- metadata %>% 
  tibble::rownames_to_column(var = "sample_id")
# adjust image orientation
metadata <- metadata %>%
  rotate_2d(
    x_col = "center_x",
    y_col = "center_y",
    degrees = image_rotation,
    origin_fn = centroid
  )
# rename new column names
colnames(metadata)[11:14] <- c("corrected_x","corrected_y","origin","rotation")
# convert origin to character (otherwise it can't be saved as h5ad later)
metadata$origin <- as.character(metadata$origin)
# turn the first row (containing cell id's) to rownames
metadata <- tibble::column_to_rownames(metadata,var = "sample_id")
# order rows in metadata and blank file to match the one in cell by gene table
metadata <- metadata[match(rownames(cbg),rownames(metadata)),]
blanks <- blanks[match(rownames(cbg),rownames(blanks)),]

################### add some basic metadata #######################
# calaculate how many different genes are detected in each cell
metadata$genes_detected <- rowSums(cbg!=0)
# calaculate how many mRNA spots are detected per cell
metadata$total_reads <- rowSums(cbg)
# calaculate how many blank spots are detected per cell
metadata$total_blanks <- rowSums(blanks)
# calaculate density of spots per cell
metadata$spot_density <- (metadata$total_reads/metadata$volume)*1000
# calculate the highest number a balnk spot was detected
metadata$max_blank_count <- rowMaxs(as.matrix(blanks[,c(-1)]))
# calculate how many different blanks are detected per cell
metadata$blanks_detected <- rowSums(blanks!=0)

######################## filter data ###############################
# add column to metadata that indicates cell quality as high or low
metadata <- metadata %>% 
  mutate(cell_qc = if_else(genes_detected < min_genes | 
                             total_reads < min_counts| 
                             volume < min_vol |
                             volume > max_vol |
                             genes_detected > max_genes |
                             total_reads > max_counts, 
                           "Low","High"))


######################## gene name converison ##########################

GeneNames                            = gene_name_conversion$Vizgen.Gene
includeClas                          = colnames(cbg)
excludeClas                          = sort(setdiff(GeneNames,includeClas))
kpSamp                               = !is.element(GeneNames,excludeClas)
gene_name_conversion_filtered        = gene_name_conversion[kpSamp,]

cbg <- cbg[,order(colnames(cbg))]
gene_name_conversion_ordered <- gene_name_conversion_filtered[order(gene_name_conversion_filtered$Vizgen.Gene), ]

allen_genes <- gene_name_conversion_ordered[,1]

colnames(cbg) <- allen_genes

############################### filter cellxgene table #########################
# combine blanks and cbg back together
cbg <- merge(cbg,
             blanks,
             by=0)
# turn the first row (containing cell id's) to rownames
cbg <- tibble::column_to_rownames(cbg,var="Row.names")
# order rows in metadata file to match the one in cell by gene table
cbg <- cbg[match(rownames(metadata),rownames(cbg)),]

# filter metadata to only contain high quality cells
metadata_subset <- metadata %>% 
  dplyr::filter(cell_qc == "High") 
# filter cell by gene to only contain high quality cells
to_keep_org <- intersect(rownames(cbg),rownames(metadata_subset))
cbg_filtered <- cbg[to_keep_org,]
cbg_filtered <- as.matrix(cbg_filtered)
# normalize cells by volume (counts per Âµm)
cbg_cpum <- (cbg_filtered / metadata_subset$volume*1000)
# log normalize data
cbg_norm <- log2(cbg_cpum+1)
# order rows between cell by genes tables and metadata to match each other
cbg_norm <- cbg_norm[match(rownames(cbg_cpum),rownames(cbg_norm)),]
cbg_filtered <- cbg_filtered[match(rownames(cbg_cpum),rownames(cbg_filtered)),]
# save log normalized file to .rda for later mapping
save(cbg_norm, file=paste0(outputFolder,section,"/norm.dat.rda"))

########## create coordinates matrix to display in cirro and squidpy ########
# subset coordinates with only good cells for cirro
coordinates_cirro <- metadata %>% 
  dplyr::filter(cell_qc == "High") %>% 
  dplyr::select(corrected_x,corrected_y)
# subset coordinates with only good cells for squidpy/scanpy
coordinates_sq <- metadata %>% 
  dplyr::filter(cell_qc == "High") %>% 
  dplyr::select(corrected_x,corrected_y)

# invert y-axis
coordinates_cirro$corrected_y = -(coordinates_cirro$corrected_y - mean(coordinates_cirro$corrected_y))
coordinates_cirro$corrected_x = coordinates_cirro$corrected_x - min(coordinates_cirro$corrected_x)

############### convert to anndata file and save #########################

ad <- AnnData(
  X = cbg_cpum,
  layers = list(
    raw = cbg_filtered,
    log2p = cbg_norm
  ),
  obs = metadata_subset,
  obsm = list(
    spatial = as.matrix(coordinates_sq),
    spatial_cirro = as.matrix(coordinates_cirro)
  )
)

write_h5ad(ad,paste0(outputFolder,section,"/",section,".h5ad"))

# empty environment to save RAM during mapping
rm(list=ls())

# load gene names of good genes
MFISH500 <- read.csv("/allen/programs/celltypes/workgroups/rnaseqanalysis/yzizhen/joint_analysis/forebrain_new/Vizgen/AIBS_MERFISH_500genes_with_notes.csv")
MFISHgenes = MFISH500 %>% filter(targetable & sufficient_target_regions) %>% select(X.1)

# load back anndata file
section <- "202202221441_60988207_VMSC01001"
inputFolder <- "/allen/programs/celltypes/workgroups/rnaseqanalysis/mFISH/michaelkunst/test_data/merfish_output/"
outputFolder <- "/allen/programs/celltypes/workgroups/rnaseqanalysis/mFISH/michaelkunst/test_data/merfish_processed/"

ad <- read_h5ad(paste0(outputFolder,section,"/",section,".h5ad"))

# extract log normalized data
qdat = t(ad$layers['log2p'])
common = intersect(rownames(qdat), MFISHgenes$X.1)
norm.dat <- qdat[common,]

# remove unnecessary files to save memory
rm(ad,qdat)

source("/allen/programs/celltypes/workgroups/rnaseqanalysis/changkyul/Mapping_On_Taxonomy/hmapping/hmapping_util.R")

mapped = run_mapping_on_taxonomy(
  norm.dat,           # query data
  Taxonomy="AIT10.0_mouse",      # taxonomy # AIT10.0_mouse : WholeBrain 10xv3
  prefix="MFISH__609882",                # prefix for your data platform (SS, 10X_cells_v2, 10X_cells_v3, 
  #                                10X_nuclei_v3, MFISH)
  prebuild=TRUE,                 # use it if the taxonomy training template is available 
  # for your data platform
  newbuild=TRUE,                 # TRUE marker selection from available genes 
  # FALSE take intersection (available genes, marker genes)
  mapping.method='hierarchy',    # 'flat','hierarchy'
  mc.cores=40,                   # lower this to 5 if the run fails due to the memory
  iter=20,
  blocksize=50000)

save(mapped,file=paste0(outputFolder,section,"/mapped_hkn.rda"))
