<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>sis.spot_table &#8212; Spots-in-Spaaaaaace! 0.0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=12dfc556" />
    <script src="../../_static/documentation_options.js?v=d45e8c67"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for sis.spot_table</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>
<span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">json</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">Delaunay</span>
<span class="kn">import</span> <span class="nn">pandas</span>

<span class="kn">from</span> <span class="nn">.optional_import</span> <span class="kn">import</span> <span class="n">optional_import</span>
<span class="n">tqdm</span> <span class="o">=</span> <span class="n">optional_import</span><span class="p">(</span><span class="s1">&#39;tqdm.notebook&#39;</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;tqdm&#39;</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">geojson</span> <span class="o">=</span> <span class="n">optional_import</span><span class="p">(</span><span class="s1">&#39;geojson&#39;</span><span class="p">)</span>
<span class="n">shapely</span> <span class="o">=</span> <span class="n">optional_import</span><span class="p">(</span><span class="s1">&#39;shapely&#39;</span><span class="p">)</span>
<span class="n">MultiLineString</span> <span class="o">=</span> <span class="n">optional_import</span><span class="p">(</span><span class="s1">&#39;shapely.geometry&#39;</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;MultiLineString&#39;</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">unary_union</span><span class="p">,</span> <span class="n">polygonize</span> <span class="o">=</span> <span class="n">optional_import</span><span class="p">(</span><span class="s1">&#39;shapely.ops&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;unary_union&#39;</span><span class="p">,</span> <span class="s1">&#39;polygonize&#39;</span><span class="p">])</span>

<span class="kn">from</span> <span class="nn">.image</span> <span class="kn">import</span> <span class="n">ImageFile</span><span class="p">,</span> <span class="n">ImageStack</span><span class="p">,</span> <span class="n">ImageTransform</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">util</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_version</span>

<div class="viewcode-block" id="run_cell_polygon_calculation">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.run_cell_polygon_calculation">[docs]</a>
<span class="k">def</span> <span class="nf">run_cell_polygon_calculation</span><span class="p">(</span><span class="n">load_func</span><span class="p">,</span> <span class="n">load_args</span><span class="p">:</span><span class="nb">dict</span><span class="p">,</span> <span class="n">subregion</span><span class="p">:</span> <span class="nb">str</span><span class="o">|</span><span class="nb">tuple</span><span class="o">|</span><span class="kc">None</span><span class="p">,</span> <span class="n">cell_id_file</span><span class="p">:</span><span class="nb">str</span><span class="o">|</span><span class="kc">None</span><span class="p">,</span> <span class="n">cell_subset_file</span><span class="p">:</span><span class="nb">str</span><span class="o">|</span><span class="kc">None</span><span class="p">,</span> <span class="n">result_file</span><span class="p">:</span><span class="nb">str</span><span class="o">|</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha_inv_coeff</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Load a spot table, calculate the cell polygons (possibly on a subset of cells), and save the result.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Load the spottable and the ids</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Loading SpotTable...&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">spot_table</span> <span class="o">=</span> <span class="n">load_func</span><span class="p">(</span><span class="o">**</span><span class="n">load_args</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">subregion</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">subregion</span> <span class="o">=</span> <span class="n">spot_table</span><span class="o">.</span><span class="n">get_image</span><span class="p">(</span><span class="n">channel</span><span class="o">=</span><span class="n">subregion</span><span class="p">)</span><span class="o">.</span><span class="n">bounds</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subregion</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">subregion</span>
        <span class="n">spot_table</span> <span class="o">=</span> <span class="n">spot_table</span><span class="o">.</span><span class="n">get_subregion</span><span class="p">(</span><span class="o">*</span><span class="n">subregion</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;subregion </span><span class="si">{</span><span class="n">subregion</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">spot_table</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cell_id_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">spot_table</span><span class="o">.</span><span class="n">cell_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">cell_id_file</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;[DONE]&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">cell_subset_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cells_to_run</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">cell_subset_file</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cells_to_run</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">spot_table</span><span class="o">.</span><span class="n">cell_ids</span><span class="p">)</span>
        <span class="n">cells_to_run</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">cells_to_run</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">cells_to_run</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">cells_to_run</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)))</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Calculating Cell Polygons...&#39;</span><span class="p">)</span>
    <span class="n">spot_table</span><span class="o">.</span><span class="n">calculate_cell_polygons</span><span class="p">(</span><span class="n">cells_to_run</span><span class="o">=</span><span class="n">cells_to_run</span><span class="p">,</span> <span class="n">alpha_inv_coeff</span><span class="o">=</span><span class="n">alpha_inv_coeff</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Saving Cell Polygons...&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">spot_table</span><span class="o">.</span><span class="n">save_cell_polygons</span><span class="p">(</span><span class="n">result_file</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;[DONE]&#39;</span><span class="p">)</span></div>



<div class="viewcode-block" id="SpotTable">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable">[docs]</a>
<span class="k">class</span> <span class="nc">SpotTable</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Represents a spatial transcriptomics spot table.</span>
<span class="sd">    </span>
<span class="sd">    - Contains x, y, z, gene per spot</span>
<span class="sd">    - May be a subset of another table, in which case indices are tracked between tables</span>
<span class="sd">    - May contain cell IDs loaded from segmentation</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pos : array</span>
<span class="sd">        Array of shape (N, 3) giving the pos of each detected transcript.</span>
<span class="sd">    gene_names : array | None</span>
<span class="sd">        Array of shape (N,) giving the name of the gene detected in each transcript. </span>
<span class="sd">        Must specify either *gene_names* or *gene_ids*, not both.</span>
<span class="sd">    gene_ids : array | None</span>
<span class="sd">        Array of shape (N,) describing the gene detected in each transcript, as an index into *gene_id_to_name*.</span>
<span class="sd">        Must specify either *gene_names* or *gene_ids*, not both.</span>
<span class="sd">    gene_id_to_name: ndarray | None</span>
<span class="sd">        Array mapping from values in *gene_ids* to string names.</span>
<span class="sd">    cell_ids : array | None</span>
<span class="sd">        Optional array of cell IDs per spot</span>
<span class="sd">    parent_table : SpotTable | None</span>
<span class="sd">        Indicates that this table is a subset of a parent SpotTable.</span>
<span class="sd">    parent_inds : array | None</span>
<span class="sd">        Indices used to select the subset of spots in this table from the parent spots.</span>
<span class="sd">    parent_region : tuple | None</span>
<span class="sd">        X,Y boundaries ((xmin, xmax), (ymin, ymax)) used to select this table from the parent table.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                 <span class="n">pos</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                 <span class="n">gene_names</span><span class="p">:</span> <span class="kc">None</span><span class="o">|</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                 <span class="n">gene_ids</span><span class="p">:</span> <span class="kc">None</span><span class="o">|</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                 <span class="n">gene_id_to_name</span><span class="p">:</span> <span class="kc">None</span><span class="o">|</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">cell_ids</span><span class="p">:</span> <span class="kc">None</span><span class="o">|</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                 <span class="n">production_cell_ids</span><span class="p">:</span> <span class="kc">None</span><span class="o">|</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">pcid_to_cid</span><span class="p">:</span> <span class="kc">None</span><span class="o">|</span><span class="nb">dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">cid_to_pcid</span><span class="p">:</span> <span class="kc">None</span><span class="o">|</span><span class="nb">dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">cell_polygons</span><span class="p">:</span> <span class="kc">None</span><span class="o">|</span><span class="nb">dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">parent_table</span><span class="p">:</span> <span class="s1">&#39;None|SpotTable&#39;</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                 <span class="n">parent_inds</span><span class="p">:</span> <span class="kc">None</span><span class="o">|</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                 <span class="n">parent_region</span><span class="p">:</span> <span class="kc">None</span><span class="o">|</span><span class="nb">tuple</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">images</span><span class="p">:</span> <span class="kc">None</span><span class="o">|</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">,):</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent_table</span> <span class="o">=</span> <span class="n">parent_table</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent_inds</span> <span class="o">=</span> <span class="n">parent_inds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent_region</span> <span class="o">=</span> <span class="n">parent_region</span>

        <span class="k">if</span> <span class="n">gene_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">gene_ids</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">gene_id_to_name</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="n">gene_ids</span><span class="p">,</span> <span class="n">gene_to_id</span><span class="p">,</span> <span class="n">id_to_gene</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_gene_index</span><span class="p">(</span><span class="n">gene_names</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gene_ids</span> <span class="o">=</span> <span class="n">gene_ids</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gene_name_to_id</span> <span class="o">=</span> <span class="n">gene_to_id</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gene_id_to_name</span> <span class="o">=</span> <span class="n">id_to_gene</span>
        <span class="k">elif</span> <span class="n">gene_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">gene_id_to_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gene_ids</span> <span class="o">=</span> <span class="n">gene_ids</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gene_id_to_name</span> <span class="o">=</span> <span class="n">gene_id_to_name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gene_name_to_id</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span><span class="nb">id</span> <span class="k">for</span> <span class="nb">id</span><span class="p">,</span><span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gene_id_to_name</span><span class="p">)}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Must specify either gene_names or gene_ids&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_gene_names</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cell_ids</span> <span class="o">=</span> <span class="n">cell_ids</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_production_cell_ids</span> <span class="o">=</span> <span class="n">production_cell_ids</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pcid_to_cid</span> <span class="o">=</span> <span class="n">pcid_to_cid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cid_to_pcid</span> <span class="o">=</span> <span class="n">cid_to_pcid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cell_index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cell_bounds</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unique_cell_ids</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cell_polygons</span> <span class="o">=</span> <span class="n">cell_polygons</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">images</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">images</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">img</span> <span class="ow">in</span> <span class="n">images</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_image</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span>

<div class="viewcode-block" id="SpotTable.dataframe">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.dataframe">[docs]</a>
    <span class="k">def</span> <span class="nf">dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cols</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a dataframe containing the specified columns.</span>

<span class="sd">        By default, columns are x, y, z, gene_ids, and cell_ids (if available).</span>
<span class="sd">        Also available: gene_names</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="s1">&#39;gene_ids&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">cols</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;cell_ids&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="n">col</span><span class="p">:</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">})</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gene_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gene_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gene_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_gene_ids_to_names</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gene_ids</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gene_names</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">y</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">z</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>

<div class="viewcode-block" id="SpotTable.map_gene_names_to_ids">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.map_gene_names_to_ids">[docs]</a>
    <span class="k">def</span> <span class="nf">map_gene_names_to_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gene_ids</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
            <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gene_name_to_id</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="SpotTable.map_gene_ids_to_names">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.map_gene_ids_to_names">[docs]</a>
    <span class="k">def</span> <span class="nf">map_gene_ids_to_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gene_id_to_name</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="nb">id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ids</span><span class="p">):</span>
            <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gene_id_to_name</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">out</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cell_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An array of cell IDs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cell_ids</span>
    
    <span class="nd">@cell_ids</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">cell_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cid</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cell_ids</span> <span class="o">=</span> <span class="n">cid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cell_ids_changed</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">production_cell_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An array of production cell IDs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_production_cell_ids</span>
    
    <span class="nd">@production_cell_ids</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">production_cell_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cid</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_production_cell_ids</span> <span class="o">=</span> <span class="n">cid</span>

<div class="viewcode-block" id="SpotTable.convert_cell_id">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.convert_cell_id">[docs]</a>
    <span class="k">def</span> <span class="nf">convert_cell_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell_id</span><span class="p">:</span> <span class="nb">int</span><span class="o">|</span><span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">production_cell_ids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;production_cell_ids must be set to use convert_cell_id()&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cell_id</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cid_to_pcid</span><span class="p">[</span><span class="n">cell_id</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cell_id</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pcid_to_cid</span><span class="p">[</span><span class="n">cell_id</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cell_id must be of type &#39;int&#39; or &#39;str&#39;&quot;</span><span class="p">)</span></div>

        
<div class="viewcode-block" id="SpotTable.bounds">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.bounds">[docs]</a>
    <span class="k">def</span> <span class="nf">bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return ((xmin, xmax), (ymin, ymax)) giving the boundaries of data included in this table.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">()),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">max</span><span class="p">())</span></div>

        
<div class="viewcode-block" id="SpotTable.cell_ids_changed">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.cell_ids_changed">[docs]</a>
    <span class="k">def</span> <span class="nf">cell_ids_changed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Call when self.cell_ids has been modified to invalidate caches.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cell_index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cell_bounds</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unique_cell_ids</span> <span class="o">=</span> <span class="kc">None</span></div>

        
<div class="viewcode-block" id="SpotTable.unique_cell_ids">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.unique_cell_ids">[docs]</a>
    <span class="k">def</span> <span class="nf">unique_cell_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;numpy array of unique cell ids (excluding background)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unique_cell_ids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">unique_cell_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_ids</span><span class="p">)</span> <span class="c1"># Pull out unique cell ids</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">unique_cell_ids</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">unique_cell_ids</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">unique_cell_ids</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)))</span> <span class="c1"># Remove background ids</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unique_cell_ids</span></div>

        
<div class="viewcode-block" id="SpotTable.get_subregion">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.get_subregion">[docs]</a>
    <span class="k">def</span> <span class="nf">get_subregion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xlim</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">ylim</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">incl_end</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a SpotTable including the subset of this table inside the region xlim, ylim</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">xlim</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> 
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">&lt;</span>  <span class="n">xlim</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span> 
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="n">ylim</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> 
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">&lt;</span>  <span class="n">ylim</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="n">sub</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="n">sub</span><span class="o">.</span><span class="n">parent_region</span> <span class="o">=</span> <span class="p">(</span><span class="n">xlim</span><span class="p">,</span> <span class="n">ylim</span><span class="p">)</span>
        <span class="n">sub</span><span class="o">.</span><span class="n">images</span> <span class="o">=</span> <span class="p">[</span><span class="n">img</span><span class="o">.</span><span class="n">get_subregion</span><span class="p">(</span><span class="n">sub</span><span class="o">.</span><span class="n">parent_region</span><span class="p">,</span> <span class="n">incl_end</span><span class="o">=</span><span class="n">incl_end</span><span class="p">)</span> <span class="k">for</span> <span class="n">img</span> <span class="ow">in</span> <span class="n">sub</span><span class="o">.</span><span class="n">images</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">sub</span></div>


<div class="viewcode-block" id="SpotTable.get_genes">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.get_genes">[docs]</a>
    <span class="k">def</span> <span class="nf">get_genes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gene_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gene_ids</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a subtable containing only the genes specified by either gene_names or gene_ids.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gene_indices</span><span class="p">(</span><span class="n">gene_names</span><span class="o">=</span><span class="n">gene_names</span><span class="p">,</span> <span class="n">gene_ids</span><span class="o">=</span><span class="n">gene_ids</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span></div>


<div class="viewcode-block" id="SpotTable.save_csv">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.save_csv">[docs]</a>
    <span class="k">def</span> <span class="nf">save_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">columns</span><span class="p">:</span> <span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save a CSV file with columns x, y, z, gene_id, [gene_name, cell_id].</span>
<span class="sd">        </span>
<span class="sd">        Optionally, use the *columns* argument to specify which columns to write.</span>
<span class="sd">        By default, the cell ID column is only present if cell IDs are available.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># can&#39;t use np.savetext since columns are spread over multiple arrays.</span>
        
        <span class="c1"># where to find data for each CSV column</span>
        <span class="n">col_data</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span>
            <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span>
            <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">,</span>
            <span class="s1">&#39;gene_id&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">gene_ids</span><span class="p">,</span>
            <span class="s1">&#39;cell_id&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_ids</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="s1">&#39;gene_name&#39;</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
            <span class="n">col_data</span><span class="p">[</span><span class="s1">&#39;gene_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gene_names</span>
        
        <span class="c1"># how to format each CSV column</span>
        <span class="n">col_fmts</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="s1">&#39;0.7g&#39;</span><span class="p">,</span>
            <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="s1">&#39;0.7g&#39;</span><span class="p">,</span>
            <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="s1">&#39;0.7g&#39;</span><span class="p">,</span>
            <span class="s1">&#39;gene_id&#39;</span><span class="p">:</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span>
            <span class="s1">&#39;gene_name&#39;</span><span class="p">:</span> <span class="s1">&#39;s&#39;</span><span class="p">,</span>
            <span class="s1">&#39;cell_id&#39;</span><span class="p">:</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span>
        <span class="p">}</span>
        
        <span class="c1"># which columns to write?</span>
        <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="s1">&#39;gene_id&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;cell_id&#39;</span><span class="p">)</span>
                
        <span class="c1"># write csv</span>
        <span class="n">header</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span>
        <span class="n">line_format</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;{</span><span class="si">%s</span><span class="s1">:</span><span class="si">%s</span><span class="s1">}&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">col_fmts</span><span class="p">[</span><span class="n">col</span><span class="p">])</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">])</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
            <span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">header</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">line_format</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">col</span><span class="p">:</span><span class="n">col_data</span><span class="p">[</span><span class="n">col</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">})</span>
                <span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                <span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpotTable.save_json">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.save_json">[docs]</a>
    <span class="k">def</span> <span class="nf">save_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">json_file</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save parent_region and parent_inds to json.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">json_data</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;parent_region&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="nb">float</span><span class="p">(</span><span class="n">rgn</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">rgn</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="k">for</span> <span class="n">rgn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_region</span><span class="p">],</span>
            <span class="s1">&#39;parent_inds&#39;</span><span class="p">:</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_inds</span><span class="p">],</span>
        <span class="p">}</span>
        <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">json_data</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">json_file</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">))</span></div>


<div class="viewcode-block" id="SpotTable.load_json">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.load_json">[docs]</a>
    <span class="k">def</span> <span class="nf">load_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">json_file</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a subset of this table as described by a json file (previously saved with save_json)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">json_data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">json_file</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">))</span>
        <span class="n">sub_table</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">json_data</span><span class="p">[</span><span class="s1">&#39;parent_inds&#39;</span><span class="p">]]</span>
        <span class="n">sub_table</span><span class="o">.</span><span class="n">parent_region</span> <span class="o">=</span> <span class="n">json_data</span><span class="p">[</span><span class="s1">&#39;parent_region&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">sub_table</span></div>


<div class="viewcode-block" id="SpotTable.load_pickle">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.load_pickle">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load_pickle</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">file_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new SpotTable loaded a SpotTable pickle stored on disk</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">pickle</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">table</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">table</span></div>


<div class="viewcode-block" id="SpotTable.load_baysor">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.load_baysor">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load_baysor</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">file_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new SpotTable loaded from a baysor result file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">load_baysor_result</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">result</span><span class="p">[[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">result</span><span class="o">.</span><span class="n">dtypes</span><span class="o">.</span><span class="n">fields</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">SpotTable</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">gene_ids</span><span class="o">=</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;gene&#39;</span><span class="p">],</span> <span class="n">cell_ids</span><span class="o">=</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">])</span></div>


<div class="viewcode-block" id="SpotTable.load_merscope">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.load_merscope">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load_merscope</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">csv_file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">cache_file</span><span class="p">:</span> <span class="nb">str</span><span class="o">|</span><span class="kc">None</span><span class="p">,</span> <span class="n">image_path</span><span class="p">:</span> <span class="nb">str</span><span class="o">|</span><span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_rows</span><span class="p">:</span> <span class="nb">int</span><span class="o">|</span><span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load MERSCOPE data from a detected transcripts CSV file.</span>

<span class="sd">        CSV reading is slow, so optionally cache the result to a .npz file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cache_file</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">cache_file</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Loading csv..&quot;</span><span class="p">)</span>

            <span class="c1"># Which columns are present in csv file?</span>
            <span class="n">cols_in_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">csv_file</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
            <span class="n">cols_in_file</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cols_in_file</span><span class="p">]</span>

            <span class="c1"># decide which columns to use for each data source</span>
            <span class="n">col_map</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="s1">&#39;global_x&#39;</span> <span class="ow">in</span> <span class="n">cols_in_file</span><span class="p">:</span>
                <span class="n">col_map</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="s1">&#39;global_x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="s1">&#39;global_y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="s1">&#39;global_z&#39;</span><span class="p">})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">col_map</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="s1">&#39;z&#39;</span><span class="p">})</span>
            <span class="n">col_map</span><span class="p">[</span><span class="s1">&#39;gene&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;gene&#39;</span>
            <span class="k">if</span> <span class="s1">&#39;cell_id&#39;</span> <span class="ow">in</span> <span class="n">cols_in_file</span><span class="p">:</span>
                <span class="n">col_map</span><span class="p">[</span><span class="s1">&#39;cell_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;cell_id&#39;</span>
            <span class="n">col_inds</span> <span class="o">=</span> <span class="p">[</span><span class="n">cols_in_file</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">col_map</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>

            <span class="c1"># pick final dtypes</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;gene&#39;</span><span class="p">,</span> <span class="s1">&#39;S20&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;cell_id&#39;</span><span class="p">,</span> <span class="s1">&#39;int64&#39;</span><span class="p">)]</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="p">[</span><span class="n">field</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">dtype</span> <span class="k">if</span> <span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">col_map</span><span class="p">]</span>

            <span class="c1"># convert positions to 2D array</span>
            <span class="n">raw_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">csv_file</span><span class="p">,</span> <span class="n">skiprows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">usecols</span><span class="o">=</span><span class="n">col_inds</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">max_rows</span><span class="o">=</span><span class="n">max_rows</span><span class="p">)</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">raw_data</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">raw_data</span><span class="p">),</span> <span class="n">raw_data</span><span class="o">.</span><span class="n">itemsize</span><span class="o">//</span><span class="mi">4</span><span class="p">)[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>

            <span class="c1"># get gene names as fixed-length string</span>
            <span class="n">max_gene_len</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">raw_data</span><span class="p">[</span><span class="s1">&#39;gene&#39;</span><span class="p">]))</span>
            <span class="n">gene_names</span> <span class="o">=</span> <span class="n">raw_data</span><span class="p">[</span><span class="s1">&#39;gene&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;U</span><span class="si">{</span><span class="n">max_gene_len</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="c1"># get cell IDs if possible</span>
            <span class="n">cell_ids</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="s1">&#39;cell_id&#39;</span> <span class="ow">in</span> <span class="n">col_map</span><span class="p">:</span>
                <span class="n">cell_ids</span> <span class="o">=</span> <span class="n">raw_data</span><span class="p">[</span><span class="s1">&#39;cell_id&#39;</span><span class="p">]</span>

            <span class="c1"># make a spot table!</span>
            <span class="n">table</span> <span class="o">=</span> <span class="n">SpotTable</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">gene_names</span><span class="o">=</span><span class="n">gene_names</span><span class="p">,</span> <span class="n">cell_ids</span><span class="o">=</span><span class="n">cell_ids</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">cache_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>                
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Recompressing to npz..&quot;</span><span class="p">)</span>
                <span class="n">table</span><span class="o">.</span><span class="n">save_npz</span><span class="p">(</span><span class="n">cache_file</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Loading from npz..&quot;</span><span class="p">)</span>
            <span class="n">table</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">load_npz</span><span class="p">(</span><span class="n">cache_file</span><span class="p">)</span>

        <span class="c1"># if requested, look for images as well (these are not saved in cache file)</span>
        <span class="n">images</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">image_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">images</span> <span class="o">=</span> <span class="n">ImageStack</span><span class="o">.</span><span class="n">load_merscope_stacks</span><span class="p">(</span><span class="n">image_path</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">img</span> <span class="ow">in</span> <span class="n">images</span><span class="p">:</span>
                <span class="n">table</span><span class="o">.</span><span class="n">add_image</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">table</span></div>


<div class="viewcode-block" id="SpotTable.load_stereoseq">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.load_stereoseq">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load_stereoseq</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">gem_file</span><span class="p">:</span> <span class="nb">str</span><span class="o">|</span><span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cache_file</span><span class="p">:</span> <span class="nb">str</span><span class="o">|</span><span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gem_cols</span><span class="p">:</span> <span class="nb">dict</span><span class="o">|</span><span class="nb">tuple</span><span class="o">=</span><span class="p">((</span><span class="s1">&#39;gene&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;MIDcounts&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span> 
                       <span class="n">cell_col</span><span class="p">:</span> <span class="nb">int</span><span class="o">|</span><span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skiprows</span><span class="p">:</span> <span class="nb">int</span><span class="o">|</span><span class="kc">None</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>  <span class="n">max_rows</span><span class="p">:</span> <span class="nb">int</span><span class="o">|</span><span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">image_file</span><span class="p">:</span> <span class="nb">str</span><span class="o">|</span><span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">image_channel</span><span class="p">:</span> <span class="nb">str</span><span class="o">|</span><span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load StereoSeq data from gem file. This can be slow so optionally cache the result to a .npz file.</span>
<span class="sd">        1/19/2023: New StereoSeq data has cell_ids, add optional cell_cols to add to SpotTable. Also has a flag</span>
<span class="sd">        for whether the spot was in the main cell or the extended cell (in_cell)</span>
<span class="sd">        1/3/2024: new cellbin.gem doesn&#39;t have `in_cell`, let&#39;s not worry about it and just specify the column </span>
<span class="sd">        that the cell ID is in</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">xyscale</span> <span class="o">=</span> <span class="mf">0.5</span>  <span class="c1"># um per unit (stereoseq spots are separated by 500 nm)</span>

        <span class="k">if</span> <span class="n">cache_file</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">cache_file</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Loading gem...&#39;</span><span class="p">)</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;gene&#39;</span><span class="p">,</span> <span class="s1">&#39;S20&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;MIDcounts&#39;</span><span class="p">,</span> <span class="s1">&#39;int&#39;</span><span class="p">)]</span>
            <span class="n">gem_cols</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">gem_cols</span><span class="p">)</span>
            <span class="n">usecols</span> <span class="o">=</span> <span class="p">[</span><span class="n">gem_cols</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;gene&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;MIDcounts&#39;</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">cell_col</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dtype</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;cell_ids&#39;</span><span class="p">,</span> <span class="s1">&#39;int&#39;</span><span class="p">))</span>
                <span class="n">usecols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cell_col</span><span class="p">)</span> 
            <span class="n">fh</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">gem_file</span><span class="p">,</span> <span class="s1">&#39;r+&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">skiprows</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="p">[</span><span class="n">fh</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">skiprows</span><span class="p">)]</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">gene_ids</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">cell_ids</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">gene_name_to_id</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">next_gene_id</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">file_size</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">gem_file</span><span class="p">)</span><span class="o">.</span><span class="n">st_size</span>
            <span class="n">n_rows</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">bytes_read</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">hit_max_rows</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">with</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="n">file_size</span><span class="p">)</span> <span class="k">as</span> <span class="n">pbar</span><span class="p">:</span>
                <span class="k">while</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">file_size</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">hit_max_rows</span><span class="p">:</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="n">fh</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
                    <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000000</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">bytes_read</span> <span class="o">&gt;=</span> <span class="n">file_size</span><span class="p">:</span>
                            <span class="k">break</span>
                        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fh</span><span class="o">.</span><span class="n">readline</span><span class="p">())</span>
                        <span class="n">n_rows</span> <span class="o">+=</span> <span class="n">i</span>  
                        <span class="n">bytes_read</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">max_rows</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">max_rows</span> <span class="o">&lt;=</span> <span class="n">n_rows</span><span class="p">:</span>
                            <span class="n">hit_max_rows</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="n">extra_rows</span> <span class="o">=</span> <span class="n">n_rows</span> <span class="o">-</span> <span class="n">max_rows</span>
                            <span class="n">lines</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[:</span><span class="o">-</span><span class="n">extra_rows</span><span class="p">]</span>
                            <span class="k">break</span>
              
                    <span class="n">raw_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">usecols</span><span class="o">=</span><span class="n">usecols</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
                    <span class="n">end</span> <span class="o">=</span> <span class="n">fh</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
                    <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">raw_data</span><span class="p">[</span><span class="s1">&#39;MIDcounts&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint8&#39;</span><span class="p">)</span>
                    <span class="n">pos2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">sum</span><span class="p">(</span><span class="n">counts</span><span class="p">),</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
                    <span class="n">pos2</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">raw_data</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">xyscale</span><span class="p">,</span> <span class="n">counts</span><span class="p">)</span>
                    <span class="n">pos2</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">raw_data</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">xyscale</span><span class="p">,</span> <span class="n">counts</span><span class="p">)</span>
                    <span class="n">pos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pos2</span><span class="p">)</span>
                    <span class="n">genes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">raw_data</span><span class="p">[</span><span class="s1">&#39;gene&#39;</span><span class="p">],</span> <span class="n">counts</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">gene</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">raw_data</span><span class="p">[</span><span class="s1">&#39;gene&#39;</span><span class="p">]):</span>
                        <span class="k">if</span> <span class="n">gene</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">gene_name_to_id</span><span class="p">:</span>
                            <span class="n">gene_name_to_id</span><span class="p">[</span><span class="n">gene</span><span class="p">]</span> <span class="o">=</span> <span class="n">next_gene_id</span>
                            <span class="n">next_gene_id</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">gene_ids2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">gene_name_to_id</span><span class="p">[</span><span class="n">gene</span><span class="p">]</span> <span class="k">for</span> <span class="n">gene</span> <span class="ow">in</span> <span class="n">genes</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint32&#39;</span><span class="p">)</span>
                    <span class="n">gene_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gene_ids2</span><span class="p">)</span>
                    <span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">cell_col</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">cell_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">raw_data</span><span class="p">[</span><span class="s1">&#39;cell_ids&#39;</span><span class="p">],</span> <span class="n">counts</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;uint16&#39;</span><span class="p">))</span>
            <span class="n">gene_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">gene_ids</span><span class="p">)</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
            <span class="n">max_len</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">gene_name_to_id</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
            <span class="n">gene_id_to_name</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gene_name_to_id</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;U</span><span class="si">{</span><span class="n">max_len</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">gene</span><span class="p">,</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">gene_name_to_id</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">gene_id_to_name</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">gene</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell_ids</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">cell_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">cell_ids</span><span class="p">)</span>
                <span class="n">table</span> <span class="o">=</span> <span class="n">SpotTable</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">gene_ids</span><span class="o">=</span><span class="n">gene_ids</span><span class="p">,</span> <span class="n">gene_id_to_name</span><span class="o">=</span><span class="n">gene_id_to_name</span><span class="p">,</span> <span class="n">cell_ids</span><span class="o">=</span><span class="n">cell_ids</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">table</span> <span class="o">=</span> <span class="n">SpotTable</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">gene_ids</span><span class="o">=</span><span class="n">gene_ids</span><span class="p">,</span> <span class="n">gene_id_to_name</span><span class="o">=</span><span class="n">gene_id_to_name</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">cache_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>                
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Recompressing to npz..&quot;</span><span class="p">)</span>
                <span class="n">table</span><span class="o">.</span><span class="n">save_npz</span><span class="p">(</span><span class="n">cache_file</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Loading from npz..&quot;</span><span class="p">)</span>
            <span class="n">table</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">load_npz</span><span class="p">(</span><span class="n">cache_file</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">image_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="n">ImageTransform</span><span class="p">(</span><span class="n">matrix</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">xyscale</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="p">[</span><span class="mi">1</span><span class="o">/</span><span class="n">xyscale</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">))</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">ImageFile</span><span class="p">(</span><span class="n">file</span><span class="o">=</span><span class="n">image_file</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;frame&#39;</span><span class="p">,</span> <span class="s1">&#39;row&#39;</span><span class="p">,</span> <span class="s1">&#39;col&#39;</span><span class="p">,</span> <span class="s1">&#39;channel&#39;</span><span class="p">],</span> <span class="n">channels</span><span class="o">=</span><span class="p">[</span><span class="n">image_channel</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;mosaic&quot;</span><span class="p">)</span>
            <span class="n">table</span><span class="o">.</span><span class="n">add_image</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">table</span></div>


<div class="viewcode-block" id="SpotTable.save_npz">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.save_npz">[docs]</a>
    <span class="k">def</span> <span class="nf">save_npz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">npz_file</span><span class="p">):</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;pos&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span>
            <span class="s1">&#39;gene_ids&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">gene_ids</span><span class="p">,</span> 
            <span class="s1">&#39;gene_id_to_name&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">gene_id_to_name</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cell_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fields</span><span class="p">[</span><span class="s1">&#39;cell_ids&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cell_ids</span>    
        
        <span class="n">np</span><span class="o">.</span><span class="n">savez_compressed</span><span class="p">(</span><span class="n">npz_file</span><span class="p">,</span> <span class="o">**</span><span class="n">fields</span><span class="p">)</span> </div>


<div class="viewcode-block" id="SpotTable.load_npz">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.load_npz">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load_npz</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">npz_file</span><span class="p">):</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">npz_file</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">SpotTable</span><span class="p">(</span><span class="o">**</span><span class="n">fields</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_make_gene_index</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">gene_names</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Given an array of gene names, return an array of integer gene IDs and dictionaries</span>
<span class="sd">        that map from gene to ID, and from ID to gene.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">genes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">gene_names</span><span class="p">)</span>
        <span class="n">max_len</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">genes</span><span class="p">))</span>
        <span class="n">gene_to_id</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">id_to_gene</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">genes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;U</span><span class="si">{</span><span class="n">max_len</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">gene</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">genes</span><span class="p">):</span>
            <span class="n">gene_to_id</span><span class="p">[</span><span class="n">gene</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">id_to_gene</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">gene</span>

        <span class="n">gene_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">gene_to_id</span><span class="p">[</span><span class="n">gene</span><span class="p">]</span> <span class="k">for</span> <span class="n">gene</span> <span class="ow">in</span> <span class="n">gene_names</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">min_scalar_type</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">genes</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">gene_ids</span><span class="p">,</span> <span class="n">gene_to_id</span><span class="p">,</span> <span class="n">id_to_gene</span>

<div class="viewcode-block" id="SpotTable.generate_production_cell_ids">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.generate_production_cell_ids">[docs]</a>
    <span class="k">def</span> <span class="nf">generate_production_cell_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">suffix</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Generates cell ids which count up from 1 to the total cell count rather than jumping between integers.</span>
<span class="sd">            Production cell ids are of type string to allow for concatenating a prefix and/or suffix to the id</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            prefix : str</span>
<span class="sd">                String to prepend to all production cell ids</span>
<span class="sd">            suffix : str</span>
<span class="sd">                String to postpend to all production cell ids</span>

<span class="sd">            Sets</span>
<span class="sd">            ----------</span>
<span class="sd">            self.production_cell_ids</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">unique_cell_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_ids</span><span class="p">)</span> <span class="c1"># Pull out unique cell ids</span>
        <span class="n">unique_cell_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">unique_cell_ids</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">unique_cell_ids</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">unique_cell_ids</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)))</span> <span class="c1"># Remove background ids</span>

        <span class="n">cid_to_pcid</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">unique_cell_ids</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">char</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s1">%d</span><span class="si">{</span><span class="n">suffix</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_cell_ids</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))))</span> <span class="c1"># Create dictionary to map cell ids to production ids </span>
        <span class="n">cid_to_pcid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;-1&quot;</span>
        <span class="n">pcid_to_cid</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">char</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s1">%d</span><span class="si">{</span><span class="n">suffix</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_cell_ids</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)),</span> <span class="n">unique_cell_ids</span><span class="p">))</span> <span class="c1"># Create dictionary to map production cell ids to cell ids </span>
        <span class="n">pcid_to_cid</span><span class="p">[</span><span class="s2">&quot;-1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="c1"># We set the cell ids which are 0 to -1 b/c they both mean background and we want to be consistent when we use a dictionary which goes b/w production &amp; normal cell ids</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cell_ids</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_ids</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">cell_ids_changed</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">production_cell_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">cid_to_pcid</span><span class="o">.</span><span class="n">get</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_ids</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pcid_to_cid</span> <span class="o">=</span> <span class="n">pcid_to_cid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cid_to_pcid</span> <span class="o">=</span> <span class="n">cid_to_pcid</span></div>


    
<div class="viewcode-block" id="SpotTable.filter_cells">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.filter_cells">[docs]</a>
    <span class="k">def</span> <span class="nf">filter_cells</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">real_cells</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_spot_count</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a filtered spot table containing only cells matching the filter criteria.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        real_cells : bool|None</span>
<span class="sd">            If True, include only spots that are segmented to a cell (cell IDs &gt; 0)</span>
<span class="sd">        min_spot_count : int|None</span>
<span class="sd">            Include only spots that are segmented to cells with a minimum number of spots</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">real_cells</span> <span class="ow">or</span> <span class="n">min_spot_count</span><span class="p">,</span> <span class="s1">&#39;One of real_cells or min_spot_count must be specified&#39;</span>
            
        <span class="n">cells</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_ids</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">masks</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># filter out spots not associated with cells</span>
        <span class="k">if</span> <span class="n">real_cells</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">masks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cells</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># filter for min_count</span>
        <span class="k">if</span> <span class="n">min_spot_count</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">masks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">counts</span> <span class="o">&gt;=</span> <span class="n">min_spot_count</span><span class="p">)</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">masks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">masks</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">mask</span> <span class="o">&amp;=</span> <span class="n">m</span>

        <span class="n">cells</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="n">filtered_table</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_ids</span><span class="p">,</span> <span class="n">cells</span><span class="p">)]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_polygons</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># We can copy the cell polygons over because individual cells do not change</span>
            <span class="c1"># We are only adding or removing cells</span>
            <span class="n">filtered_table</span><span class="o">.</span><span class="n">cell_polygons</span> <span class="o">=</span> <span class="p">{</span><span class="n">cid</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_polygons</span><span class="p">[</span><span class="n">cid</span><span class="p">]</span> <span class="k">for</span> <span class="n">cid</span> <span class="ow">in</span> <span class="n">cells</span> <span class="k">if</span> <span class="n">cid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_polygons</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">filtered_table</span></div>


<div class="viewcode-block" id="SpotTable.cell_by_gene_dense_matrix">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.cell_by_gene_dense_matrix">[docs]</a>
    <span class="k">def</span> <span class="nf">cell_by_gene_dense_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint16&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a numpy array containing a cell-by-gene table derived from this spot table.</span>
<span class="sd">        Also return cell_ids and gene_ids used to construct the matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filtered_table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_cells</span><span class="p">(</span><span class="n">real_cells</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># Don&#39;t want to include unassigned cells</span>
        <span class="n">spot_df</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;cell&#39;</span><span class="p">:</span> <span class="n">filtered_table</span><span class="o">.</span><span class="n">cell_ids</span><span class="p">,</span> <span class="s1">&#39;gene&#39;</span><span class="p">:</span> <span class="n">filtered_table</span><span class="o">.</span><span class="n">gene_ids</span><span class="p">})</span>
        <span class="n">cell_by_gene_df</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">pivot_table</span><span class="p">(</span><span class="n">spot_df</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="s1">&#39;gene&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="s1">&#39;cell&#39;</span><span class="p">,</span> <span class="n">aggfunc</span><span class="o">=</span><span class="nb">len</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">cell_by_gene_df</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">),</span> <span class="n">cell_by_gene_df</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">cell_by_gene_df</span><span class="o">.</span><span class="n">columns</span></div>


<div class="viewcode-block" id="SpotTable.cell_by_gene_sparse_matrix">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.cell_by_gene_sparse_matrix">[docs]</a>
    <span class="k">def</span> <span class="nf">cell_by_gene_sparse_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint16&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return cell-by-gene data in a scipy.sparse.csr_matrix</span>
<span class="sd">        Also return cell_ids and gene_ids used to construct the matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">scipy.sparse</span>

        <span class="n">filtered_table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_cells</span><span class="p">(</span><span class="n">real_cells</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="c1"># collect cell and gene data. we use inds b/c csr_matrix doesn&#39;t work with unordered integer names</span>
        <span class="n">gene_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">filtered_table</span><span class="o">.</span><span class="n">gene_ids</span><span class="p">)</span>
        <span class="n">cell_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">filtered_table</span><span class="o">.</span><span class="n">cell_ids</span><span class="p">)</span>
        <span class="n">cell_id_inds</span> <span class="o">=</span> <span class="p">{</span><span class="n">cid</span><span class="p">:</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">cid</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cell_ids</span><span class="p">)}</span>
        <span class="n">gene_id_inds</span> <span class="o">=</span> <span class="p">{</span><span class="n">gid</span><span class="p">:</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">gid</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gene_ids</span><span class="p">)}</span>

        <span class="c1"># count genes per cell into a dict format </span>
        <span class="c1">#   {cell_index: {gene_index1: count1, ...}, ...}</span>
        <span class="n">cellxgene_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">filtered_table</span><span class="p">)):</span>
            <span class="n">cind</span> <span class="o">=</span> <span class="n">cell_id_inds</span><span class="p">[</span><span class="n">filtered_table</span><span class="o">.</span><span class="n">cell_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="n">gind</span> <span class="o">=</span> <span class="n">gene_id_inds</span><span class="p">[</span><span class="n">filtered_table</span><span class="o">.</span><span class="n">gene_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="n">cellrow</span> <span class="o">=</span> <span class="n">cellxgene_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">cind</span><span class="p">,</span> <span class="p">{})</span>
            <span class="n">cellrow</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">gind</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">cellrow</span><span class="p">[</span><span class="n">gind</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># convert to sparse matrix</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">rowind</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">colind</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cindex</span><span class="p">,</span> <span class="n">cellrow</span> <span class="ow">in</span> <span class="n">cellxgene_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">gindex</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">cellrow</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
                <span class="n">rowind</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cindex</span><span class="p">)</span>
                <span class="n">colind</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gindex</span><span class="p">)</span>
        
        <span class="n">cellxgene</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">rowind</span><span class="p">,</span> <span class="n">colind</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cellxgene</span><span class="p">,</span> <span class="n">cell_ids</span><span class="p">,</span> <span class="n">gene_ids</span></div>


<div class="viewcode-block" id="SpotTable.cell_by_gene_anndata">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.cell_by_gene_anndata">[docs]</a>
    <span class="k">def</span> <span class="nf">cell_by_gene_anndata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_format</span><span class="p">,</span> <span class="n">x_dtype</span><span class="o">=</span><span class="s1">&#39;uint16&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a cell x gene table in AnnData format with cell centroids in x,y obs columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">anndata</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">production_cell_ids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;production_cell_ids must be set to use cell_by_gene_anndata(). See SpotTable.generate_production_cell_ids()&#39;</span><span class="p">)</span>

        <span class="c1"># Create the anndata.X</span>
        <span class="k">if</span> <span class="n">x_format</span> <span class="o">==</span> <span class="s1">&#39;sparse&#39;</span><span class="p">:</span>
            <span class="n">cellxgene</span><span class="p">,</span> <span class="n">cell_ids</span><span class="p">,</span> <span class="n">gene_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_by_gene_sparse_matrix</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">x_dtype</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">x_format</span> <span class="o">==</span> <span class="s1">&#39;dense&#39;</span><span class="p">:</span>
            <span class="n">cellxgene</span><span class="p">,</span> <span class="n">cell_ids</span><span class="p">,</span> <span class="n">gene_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_by_gene_dense_matrix</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">x_dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x_format must be either &#39;dense&#39; or &#39;sparse&#39;&quot;</span><span class="p">)</span>
        <span class="n">adata</span> <span class="o">=</span> <span class="n">anndata</span><span class="o">.</span><span class="n">AnnData</span><span class="p">(</span><span class="n">cellxgene</span><span class="p">)</span>

        <span class="c1"># Fill obs</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">obs_names</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_cell_id</span><span class="p">(</span><span class="n">cid</span><span class="p">)</span> <span class="k">for</span> <span class="n">cid</span> <span class="ow">in</span> <span class="n">cell_ids</span><span class="p">]</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">obs</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_centroids</span><span class="p">(</span><span class="n">use_production_ids</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">left_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">right_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="c1"># Calculate cell volumes</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_polygons</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_polygons</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Default to np.nan if no cell polygons</span>
            <span class="n">cell_feature_df</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="n">cell_feature_df</span><span class="p">[[</span><span class="s1">&#39;volume&#39;</span><span class="p">,</span> <span class="s1">&#39;area&#39;</span><span class="p">,</span> <span class="s1">&#39;polygon_center_x&#39;</span><span class="p">,</span> <span class="s1">&#39;polygon_center_y&#39;</span><span class="p">,</span> <span class="s1">&#39;polygon_center_z&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cell_feature_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cell_features</span><span class="p">(</span><span class="n">use_production_ids</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">disable_tqdm</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;production_cell_id&#39;</span><span class="p">)</span>
            <span class="n">cell_feature_df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;center_x&quot;</span><span class="p">:</span> <span class="s2">&quot;polygon_center_x&quot;</span><span class="p">,</span> <span class="s2">&quot;center_y&quot;</span><span class="p">:</span> <span class="s2">&quot;polygon_center_y&quot;</span><span class="p">,</span> <span class="s2">&quot;center_z&quot;</span><span class="p">:</span> <span class="s2">&quot;polygon_center_z&quot;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">obs</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">cell_feature_df</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">left_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">right_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;SpotTable_cell_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell_ids</span>

        <span class="c1"># Fill var</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">var_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_gene_ids_to_names</span><span class="p">(</span><span class="n">gene_ids</span><span class="p">)</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;probe_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_gene_ids_to_names</span><span class="p">(</span><span class="n">gene_ids</span><span class="p">)</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;cells_with_reads&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">cellxgene</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="n">x_format</span> <span class="o">==</span> <span class="s1">&#39;dense&#39;</span> <span class="k">else</span> <span class="n">cellxgene</span><span class="o">.</span><span class="n">getnnz</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">segmented_total_reads</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cellxgene</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="k">if</span> <span class="n">x_format</span> <span class="o">==</span> <span class="s1">&#39;dense&#39;</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cellxgene</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;segmented_total_reads&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">segmented_total_reads</span>
        <span class="n">unseg_table</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_ids</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">unsegmented_total_reads</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">pivot_table</span><span class="p">(</span><span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;cell&#39;</span><span class="p">:</span> <span class="n">unseg_table</span><span class="o">.</span><span class="n">cell_ids</span><span class="p">,</span> <span class="s1">&#39;gene&#39;</span><span class="p">:</span> <span class="n">unseg_table</span><span class="o">.</span><span class="n">gene_ids</span><span class="p">}),</span> <span class="n">columns</span><span class="o">=</span><span class="s1">&#39;gene&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="s1">&#39;cell&#39;</span><span class="p">,</span> <span class="n">aggfunc</span><span class="o">=</span><span class="nb">len</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">unsegmented_total_reads</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_gene_ids_to_names</span><span class="p">(</span><span class="n">unsegmented_total_reads</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;unsegmented_total_reads&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unsegmented_total_reads</span>
        
        <span class="c1"># Fill uns</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">uns</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;segmentation_metadata&#39;</span><span class="p">:</span> <span class="p">{</span>
                                                <span class="s2">&quot;model_name&quot;</span><span class="p">:</span> <span class="s2">&quot;FILL LATER (SegmentedSpotTable)&quot;</span><span class="p">,</span>
                                                <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;FILL LATER (SegmentedSpotTable)&quot;</span><span class="p">,</span>
                                                <span class="s2">&quot;parameters&quot;</span><span class="p">:</span> <span class="s2">&quot;FILL LATER (SegmentedSpotTable)&quot;</span><span class="p">,</span>
                                            <span class="p">},</span>
                    <span class="s1">&#39;cell_polygons&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_geojson_collection</span><span class="p">(</span><span class="n">use_production_ids</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                    <span class="s1">&#39;SIS_repo_hash&#39;</span><span class="p">:</span> <span class="n">_version</span><span class="o">.</span><span class="n">get_versions</span><span class="p">()[</span><span class="s1">&#39;version&#39;</span><span class="p">],</span>
                    <span class="p">}</span>
        <span class="k">return</span> <span class="n">adata</span></div>


<div class="viewcode-block" id="SpotTable.cell_bounds">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.cell_bounds">[docs]</a>
    <span class="k">def</span> <span class="nf">cell_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell_id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return xmin, xmax, ymin, ymax for *cell_id*</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cell_bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cell_bounds</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">cid</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_ids</span><span class="p">):</span>
                <span class="n">inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_indices</span><span class="p">(</span><span class="n">cid</span><span class="p">)</span>
                <span class="n">rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cell_bounds</span><span class="p">[</span><span class="n">cid</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">rows</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
                    <span class="n">rows</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span>
                    <span class="n">rows</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
                    <span class="n">rows</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cell_bounds</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_cell_id</span><span class="p">(</span><span class="n">cell_id</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cell_id</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">cell_id</span><span class="p">]</span></div>


<div class="viewcode-block" id="SpotTable.cell_centroids">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.cell_centroids">[docs]</a>
    <span class="k">def</span> <span class="nf">cell_centroids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">use_production_ids</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a Pandas DataFrame of cell centroids calculated mean of the x,y,z coordinates for each cell.&quot;&quot;&quot;</span>
        <span class="n">centroids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_cell_ids</span><span class="p">():</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_indices</span><span class="p">(</span><span class="n">cid</span><span class="p">)</span>
            <span class="n">cell_ts_xyz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span>
            <span class="n">centroids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cell_ts_xyz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">centroids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">centroids</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">centroids</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span> <span class="c1"># If 2d, we still put in center_z column to keep consistent with 3d</span>
            <span class="n">empty</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">centroids</span><span class="p">),</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">empty</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">centroids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">centroids</span><span class="p">,</span> <span class="n">empty</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_cell_id</span><span class="p">(</span><span class="n">cid</span><span class="p">)</span> <span class="k">for</span> <span class="n">cid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_cell_ids</span><span class="p">()]</span> <span class="k">if</span> <span class="n">use_production_ids</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_cell_ids</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">centroids</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">indices</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;center_x&#39;</span><span class="p">,</span> <span class="s1">&#39;center_y&#39;</span><span class="p">,</span> <span class="s1">&#39;center_z&#39;</span><span class="p">])</span></div>


<div class="viewcode-block" id="SpotTable.cell_polygon">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.cell_polygon">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">cell_polygon</span><span class="p">(</span><span class="n">cell_points_array</span><span class="p">,</span> <span class="n">alpha_inv</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        get 2D alpha shape from a set of points, modified slightly from </span>
<span class="sd">        http://blog.thehumangeo.com/2014/05/12/drawing-boundaries-in-python/</span>

<span class="sd">        args:</span>
<span class="sd">        cell_points  numpy array of  point locations with expected columns [x,y].</span>
<span class="sd">        alpha_inv parameter that sets the radius filter on the Delaunay triangulation.  </span>
<span class="sd">                traditionally alpha is defined as 1/radius, </span>
<span class="sd">                and here the function input is inverted for slightly more intuitive use</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tri</span> <span class="o">=</span> <span class="n">Delaunay</span><span class="p">(</span><span class="n">cell_points_array</span><span class="p">,</span> <span class="n">qhull_options</span><span class="o">=</span><span class="s2">&quot;QJ&quot;</span><span class="p">)</span>
        <span class="c1"># Make a list of line segments: </span>
        <span class="c1"># edge_points = [ ((x1_1, y1_1), (x2_1, y2_1)),</span>
        <span class="c1">#                 ((x1_2, y1_2), (x2_2, y2_2)),</span>
        <span class="c1">#                 ... ]</span>

        <span class="n">edge_points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Add a line between the i-th and j-th points, if not in the list already&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="n">edges</span> <span class="ow">or</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
                <span class="c1"># already added</span>
                <span class="k">return</span>
            <span class="n">edges</span><span class="o">.</span><span class="n">add</span><span class="p">(</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="p">)</span>
            <span class="n">edge_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cell_points_array</span><span class="p">[</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="p">])</span>

        <span class="c1"># loop over triangles:</span>
        <span class="c1"># ia, ib, ic = indices of corner points of the triangle</span>
        <span class="k">for</span> <span class="n">ia</span><span class="p">,</span> <span class="n">ib</span><span class="p">,</span> <span class="n">ic</span> <span class="ow">in</span> <span class="n">tri</span><span class="o">.</span><span class="n">simplices</span><span class="p">:</span>
            <span class="n">pa</span> <span class="o">=</span> <span class="n">cell_points_array</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span>
            <span class="n">pb</span> <span class="o">=</span> <span class="n">cell_points_array</span><span class="p">[</span><span class="n">ib</span><span class="p">]</span>
            <span class="n">pc</span> <span class="o">=</span> <span class="n">cell_points_array</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span>

            <span class="c1"># Lengths of sides of triangle</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">pa</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">pb</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">pa</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">pb</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">pb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">pc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">pb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">pc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">pc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">pa</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">pc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">pa</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

            <span class="c1"># Semiperimeter of triangle</span>
            <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>

            <span class="c1"># Area of triangle by Heron&#39;s formula</span>
            <span class="n">area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">s</span><span class="o">*</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="n">c</span><span class="p">))</span>

            <span class="n">circum_r</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="o">/</span><span class="p">(</span><span class="mf">4.0</span><span class="o">*</span><span class="n">area</span><span class="p">)</span>

            <span class="c1"># Here&#39;s the radius filter.</span>
            <span class="k">if</span> <span class="n">circum_r</span> <span class="o">&lt;</span> <span class="n">alpha_inv</span><span class="p">:</span>
                <span class="n">add_edge</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">ib</span><span class="p">)</span>
                <span class="n">add_edge</span><span class="p">(</span><span class="n">ib</span><span class="p">,</span> <span class="n">ic</span><span class="p">)</span>
                <span class="n">add_edge</span><span class="p">(</span><span class="n">ic</span><span class="p">,</span> <span class="n">ia</span><span class="p">)</span>

        <span class="n">m</span> <span class="o">=</span> <span class="n">MultiLineString</span><span class="p">(</span><span class="n">edge_points</span><span class="p">)</span>
        <span class="n">triangles</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">polygonize</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
        <span class="n">tp</span> <span class="o">=</span> <span class="n">unary_union</span><span class="p">(</span><span class="n">triangles</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">tp</span></div>


<div class="viewcode-block" id="SpotTable.calculate_optimal_polygon">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.calculate_optimal_polygon">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_optimal_polygon</span><span class="p">(</span><span class="n">xy_pos</span><span class="p">,</span> <span class="n">alpha_inv</span><span class="p">,</span> <span class="n">alpha_inv_coeff</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1"># Helper function to test if an alphashape is a polygon and contains all points</span>
        <span class="k">def</span> <span class="nf">_test_polygon</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">polygon</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">polygon</span><span class="o">.</span><span class="n">Polygon</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">MultiPoint</span><span class="p">):</span>
                    <span class="n">points</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">MultiPoint</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">points</span><span class="p">))</span>
                <span class="k">return</span> <span class="nb">all</span><span class="p">([</span><span class="n">polygon</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">point</span><span class="p">))</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">points</span><span class="o">.</span><span class="n">geoms</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">xy_pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span> <span class="c1"># If there are &lt;= 3 points cannot do delaunay</span>
            <span class="n">putative_polygon</span> <span class="o">=</span> <span class="n">SpotTable</span><span class="o">.</span><span class="n">cell_polygon</span><span class="p">(</span><span class="n">xy_pos</span><span class="p">,</span> <span class="n">alpha_inv</span><span class="p">)</span>
            <span class="c1"># increase alpha_inv until we only have 1 polygon which contains all points</span>
            <span class="n">tries</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">flex_alpha_inv</span> <span class="o">=</span> <span class="n">alpha_inv</span>
            <span class="k">while</span> <span class="n">tries</span> <span class="o">&lt;</span> <span class="mi">200</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">_test_polygon</span><span class="p">(</span><span class="n">xy_pos</span><span class="p">,</span> <span class="n">putative_polygon</span><span class="p">):</span>
                <span class="n">flex_alpha_inv</span> <span class="o">+=</span> <span class="mf">.5</span>
                <span class="n">tries</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">putative_polygon</span> <span class="o">=</span> <span class="n">SpotTable</span><span class="o">.</span><span class="n">cell_polygon</span><span class="p">(</span><span class="n">xy_pos</span><span class="p">,</span> <span class="n">flex_alpha_inv</span><span class="p">)</span>

            <span class="c1"># Final check to see if we got it in the number of tries</span>
            <span class="k">if</span> <span class="n">_test_polygon</span><span class="p">(</span><span class="n">xy_pos</span><span class="p">,</span> <span class="n">putative_polygon</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">alpha_inv_coeff</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">putative_polygon</span> <span class="o">=</span> <span class="n">SpotTable</span><span class="o">.</span><span class="n">cell_polygon</span><span class="p">(</span><span class="n">xy_pos</span><span class="p">,</span> <span class="n">alpha_inv_coeff</span> <span class="o">*</span> <span class="n">flex_alpha_inv</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">putative_polygon</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># If not, we return the convex hull (only approximately by using massive alpha_inv)</span>
                <span class="k">return</span> <span class="n">SpotTable</span><span class="o">.</span><span class="n">cell_polygon</span><span class="p">(</span><span class="n">xy_pos</span><span class="p">,</span> <span class="mi">1000000</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>    
            <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="SpotTable.calculate_cell_polygons">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.calculate_cell_polygons">[docs]</a>
    <span class="k">def</span> <span class="nf">calculate_cell_polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha_inv</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">separate_z_planes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cells_to_run</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">|</span><span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha_inv_coeff</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">disable_tqdm</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cells_to_run</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># If you only want to calculate a subset of cells</span>
            <span class="n">cells_to_run</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_ids</span><span class="p">)</span>
            <span class="n">cells_to_run</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">cells_to_run</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">cells_to_run</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">cells_to_run</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)))</span>

        <span class="c1"># run through all cell_ids, generate polygons and add to self.cell_polygons dict </span>
        <span class="c1"># increases the alpha_inv parameter by 0.5 until a single polygon is generated</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cell_polygons</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">cid</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">cells_to_run</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="n">disable_tqdm</span><span class="p">):</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_indices</span><span class="p">(</span><span class="n">cid</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">separate_z_planes</span><span class="p">:</span>
                <span class="n">xyz_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">z_plane</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">xyz_pos</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]):</span>
                    <span class="n">xy_pos</span> <span class="o">=</span> <span class="n">xyz_pos</span><span class="p">[</span><span class="n">xyz_pos</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">z_plane</span><span class="p">][:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">optimal_poly</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_optimal_polygon</span><span class="p">(</span><span class="n">xy_pos</span><span class="p">,</span> <span class="n">alpha_inv</span><span class="p">,</span> <span class="n">alpha_inv_coeff</span><span class="o">=</span><span class="n">alpha_inv_coeff</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">optimal_poly</span><span class="p">:</span> <span class="c1"># Only record a polygon if a plane had a polygon (i.e. don&#39;t store None)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">cell_polygons</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">cid</span><span class="p">,</span> <span class="p">{})[</span><span class="n">z_plane</span><span class="p">]</span> <span class="o">=</span> <span class="n">optimal_poly</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cell_polygons</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">cid</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="c1"># If none of the z-planes had a polygon, set to None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">xy_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">inds</span><span class="p">][:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cell_polygons</span><span class="p">[</span><span class="n">cid</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_optimal_polygon</span><span class="p">(</span><span class="n">xy_pos</span><span class="p">,</span> <span class="n">alpha_inv</span><span class="p">,</span> <span class="n">alpha_inv_coeff</span><span class="o">=</span><span class="n">alpha_inv_coeff</span><span class="p">)</span></div>



<div class="viewcode-block" id="SpotTable.calculate_cell_features">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.calculate_cell_features">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_cell_features</span><span class="p">(</span><span class="n">cell_polygon</span><span class="p">,</span> <span class="n">z_plane_thickness</span><span class="o">=</span><span class="mf">1.5</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cell_polygon</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span> <span class="c1"># If we have separate polygons for each z-plane</span>
            <span class="n">area</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">weighted_x</span><span class="p">,</span> <span class="n">weighted_y</span><span class="p">,</span> <span class="n">weighted_z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">z</span><span class="p">,</span> <span class="n">polygon</span> <span class="ow">in</span> <span class="n">cell_polygon</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">polygon</span><span class="p">:</span>
                    <span class="n">area</span> <span class="o">+=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">area</span>
                    
                    <span class="n">weighted_x</span> <span class="o">+=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">polygon</span><span class="o">.</span><span class="n">area</span>
                    <span class="n">weighted_y</span> <span class="o">+=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">polygon</span><span class="o">.</span><span class="n">area</span>
                    <span class="n">weighted_z</span> <span class="o">+=</span> <span class="n">z</span> <span class="o">*</span> <span class="n">polygon</span><span class="o">.</span><span class="n">area</span>
                    
            <span class="n">volume</span> <span class="o">=</span> <span class="n">area</span> <span class="o">*</span> <span class="n">z_plane_thickness</span>
            <span class="n">center_x</span><span class="p">,</span> <span class="n">center_y</span><span class="p">,</span> <span class="n">center_z</span> <span class="o">=</span> <span class="n">weighted_x</span> <span class="o">/</span> <span class="n">area</span><span class="p">,</span> <span class="n">weighted_y</span> <span class="o">/</span> <span class="n">area</span><span class="p">,</span> <span class="n">weighted_z</span> <span class="o">/</span> <span class="n">area</span> <span class="c1"># we define centroid as a weighted average (by area) of centroids of polygons</span>
            
            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;volume&quot;</span><span class="p">:</span> <span class="n">volume</span><span class="p">,</span> <span class="s2">&quot;center_x&quot;</span><span class="p">:</span> <span class="n">center_x</span><span class="p">,</span> <span class="s2">&quot;center_y&quot;</span><span class="p">:</span> <span class="n">center_y</span><span class="p">,</span> <span class="s2">&quot;center_z&quot;</span><span class="p">:</span> <span class="n">center_z</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># If we have one polygon for each cell (either one representing all z-planes or just one z-plane)</span>
            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;area&quot;</span><span class="p">:</span> <span class="n">cell_polygon</span><span class="o">.</span><span class="n">area</span><span class="p">,</span> <span class="s2">&quot;center_x&quot;</span><span class="p">:</span> <span class="n">cell_polygon</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;center_y&quot;</span><span class="p">:</span> <span class="n">cell_polygon</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]}</span></div>

    
    
<div class="viewcode-block" id="SpotTable.get_cell_features">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.get_cell_features">[docs]</a>
    <span class="k">def</span> <span class="nf">get_cell_features</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z_plane_thickness</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">use_production_ids</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_both_ids</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">disable_tqdm</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># run through self.polys and calculate features</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_polygons</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_polygons</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cell polygons must be set before calculating cell features. See calculate_cell_polygons() or load_cell_polygons()&quot;</span><span class="p">)</span>

        <span class="n">cell_features</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cid</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_polygons</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="n">disable_tqdm</span><span class="p">):</span>
            <span class="n">feature_info</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;cell_id&quot;</span><span class="p">:</span><span class="n">cid</span><span class="p">,</span> <span class="s2">&quot;volume&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s2">&quot;area&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s2">&quot;center_x&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s2">&quot;center_y&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s2">&quot;center_z&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">}</span>
            <span class="k">if</span> <span class="n">use_both_ids</span><span class="p">:</span>
                <span class="n">feature_info</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;production_cell_id&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_cell_id</span><span class="p">(</span><span class="n">cid</span><span class="p">)})</span>
            <span class="k">if</span> <span class="n">use_production_ids</span><span class="p">:</span>
                <span class="n">feature_info</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;production_cell_id&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_cell_id</span><span class="p">(</span><span class="n">feature_info</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;cell_id&quot;</span><span class="p">))})</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_polygons</span><span class="p">[</span><span class="n">cid</span><span class="p">]:</span> <span class="c1"># Sometimes polygons can be None</span>
                <span class="n">feature_info</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">calculate_cell_features</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_polygons</span><span class="p">[</span><span class="n">cid</span><span class="p">],</span> <span class="n">z_plane_thickness</span><span class="o">=</span><span class="n">z_plane_thickness</span><span class="p">))</span>

            <span class="n">cell_features</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">feature_info</span><span class="p">)</span>
        
        <span class="c1"># Depending if we have separate polygons for each z-plane we want to set either the volume or area to NaN</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_records</span><span class="p">(</span><span class="n">cell_features</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">df</span></div>



<div class="viewcode-block" id="SpotTable.get_geojson_collection">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.get_geojson_collection">[docs]</a>
    <span class="k">def</span> <span class="nf">get_geojson_collection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">use_production_ids</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a geojson feature/geometry collection from the cell polygons</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">dict</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_polygons</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span> <span class="c1"># if cell polygons are separated by z-plane use feature collection which stores z-plane info</span>
            <span class="n">all_polygons</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">cid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_polygons</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_polygons</span><span class="p">[</span><span class="n">cid</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">z_plane</span><span class="p">,</span> <span class="n">polygon</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_polygons</span><span class="p">[</span><span class="n">cid</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="c1"># Each z-plane is a separate feature</span>
                        <span class="n">all_polygons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">geojson</span><span class="o">.</span><span class="n">Feature</span><span class="p">(</span><span class="n">geometry</span><span class="o">=</span><span class="n">polygon</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_cell_id</span><span class="p">(</span><span class="n">cid</span><span class="p">)</span> <span class="k">if</span> <span class="n">use_production_ids</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">cid</span><span class="p">),</span> <span class="n">z_plane</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">z_plane</span><span class="p">)))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">all_polygons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">geojson</span><span class="o">.</span><span class="n">Feature</span><span class="p">(</span><span class="n">geometry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_cell_id</span><span class="p">(</span><span class="n">cid</span><span class="p">)</span> <span class="k">if</span> <span class="n">use_production_ids</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">cid</span><span class="p">),</span> <span class="n">z_plane</span><span class="o">=</span><span class="kc">None</span><span class="p">))</span>

            <span class="k">return</span> <span class="n">geojson</span><span class="o">.</span><span class="n">FeatureCollection</span><span class="p">(</span><span class="n">all_polygons</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># If cell polygons are not separated by z-plane, use previous implementation</span>
            <span class="n">geojsonROIs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">poly_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_polygons</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_polygons</span><span class="p">[</span><span class="n">poly_key</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_polygons</span><span class="p">[</span><span class="n">poly_key</span><span class="p">]</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">geojsonROIs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">poly_to_geojson</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_polygons</span><span class="p">[</span><span class="n">poly_key</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">geojsonROIs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            
            <span class="k">return</span> <span class="n">geojson</span><span class="o">.</span><span class="n">GeometryCollection</span><span class="p">(</span><span class="n">geojsonROIs</span><span class="p">)</span></div>

    

<div class="viewcode-block" id="SpotTable.save_cell_polygons">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.save_cell_polygons">[docs]</a>
    <span class="k">def</span> <span class="nf">save_cell_polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">save_path</span><span class="p">:</span> <span class="n">Path</span><span class="o">|</span><span class="nb">str</span><span class="p">,</span> <span class="n">use_production_ids</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        save a geojson geometry collection from the cell polygons</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Handle input errors</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">save_path</span><span class="p">,</span> <span class="n">Path</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">save_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">extension</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">save_path</span><span class="p">)</span><span class="o">.</span><span class="n">suffix</span>
            <span class="k">if</span> <span class="n">extension</span> <span class="o">!=</span> <span class="s1">&#39;.pkl&#39;</span> <span class="ow">and</span> <span class="n">extension</span> <span class="o">!=</span> <span class="s1">&#39;.geojson&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid path extension. Please use .pkl or .geojson&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid path type. Please use pathlib.Path or str&#39;</span><span class="p">)</span>

        <span class="c1"># Raise error if no data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_polygons</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_polygons</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No cell polygon data, cannot save file&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">extension</span> <span class="o">==</span> <span class="s1">&#39;.geojson&#39;</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">geojson</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_geojson_collection</span><span class="p">(</span><span class="n">use_production_ids</span><span class="o">=</span><span class="n">use_production_ids</span><span class="p">),</span> <span class="n">f</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">pickle</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_path</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_polygons</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span></div>


    
<div class="viewcode-block" id="SpotTable.load_cell_polygons">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.load_cell_polygons">[docs]</a>
    <span class="k">def</span> <span class="nf">load_cell_polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">load_path</span><span class="p">:</span> <span class="n">Path</span><span class="o">|</span><span class="nb">str</span><span class="p">,</span> <span class="n">reset_cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">disable_tqdm</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        load cell polygons from a geojson feature collection file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Handle input errors</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">load_path</span><span class="p">,</span> <span class="n">Path</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">load_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">extension</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">load_path</span><span class="p">)</span><span class="o">.</span><span class="n">suffix</span>
            <span class="k">if</span> <span class="n">extension</span> <span class="o">!=</span> <span class="s1">&#39;.pkl&#39;</span> <span class="ow">and</span> <span class="n">extension</span> <span class="o">!=</span> <span class="s1">&#39;.geojson&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid path extension. Can only load .pkl or .geojson&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid path type. Please use pathlib.Path or str&#39;</span><span class="p">)</span>
    
        <span class="k">if</span> <span class="n">reset_cache</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_polygons</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cell_polygons</span> <span class="o">=</span> <span class="p">{}</span>
    
        <span class="k">if</span> <span class="n">extension</span> <span class="o">==</span> <span class="s1">&#39;.geojson&#39;</span><span class="p">:</span> 
            <span class="kn">import</span> <span class="nn">json</span>
            <span class="kn">from</span> <span class="nn">shapely.geometry.polygon</span> <span class="kn">import</span> <span class="n">Polygon</span>
    
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">load_path</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">polygon_json</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    
            <span class="n">unique_cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_ids</span><span class="p">)</span>
            <span class="n">unique_cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">unique_cells</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">unique_cells</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">unique_cells</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)))</span>
            <span class="n">cell_id_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">unique_cells</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">z_plane_type</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="k">else</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
    
            <span class="k">if</span> <span class="n">polygon_json</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;FeatureCollection&#39;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">polygon_json</span><span class="p">[</span><span class="s1">&#39;features&#39;</span><span class="p">],</span> <span class="n">disable</span><span class="o">=</span><span class="n">disable_tqdm</span><span class="p">):</span>
                    <span class="n">cid</span> <span class="o">=</span> <span class="n">cell_id_type</span><span class="p">(</span><span class="n">feature</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">cid</span> <span class="ow">in</span> <span class="n">unique_cells</span><span class="p">:</span>
                        <span class="c1"># Make sure it is a polygon or None otherwise we don&#39;t read it</span>
                        <span class="k">if</span> <span class="n">feature</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">feature</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">][</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Polygon&#39;</span><span class="p">:</span> 
                            <span class="n">z_plane</span> <span class="o">=</span> <span class="n">z_plane_type</span><span class="p">(</span><span class="n">feature</span><span class="p">[</span><span class="s1">&#39;z_plane&#39;</span><span class="p">])</span>
                            <span class="n">polygon</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">feature</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">][</span><span class="s1">&#39;coordinates&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">cell_polygons</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">cid</span><span class="p">,</span> <span class="p">{})[</span><span class="n">z_plane</span><span class="p">]</span> <span class="o">=</span> <span class="n">polygon</span>
                        <span class="k">elif</span> <span class="ow">not</span> <span class="n">feature</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">cell_polygons</span><span class="p">[</span><span class="n">cid</span><span class="p">]</span> <span class="o">=</span> <span class="n">feature</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">polygon_json</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;GeometryCollection&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_cells</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">polygon_json</span><span class="p">[</span><span class="s1">&#39;geometries&#39;</span><span class="p">]):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Number of cells in input file exceeds SpotTable&quot;</span><span class="p">)</span>

                <span class="c1"># This method ensure compatibility with both JSONs which store None and those which dont</span>
                <span class="n">valid_cells</span> <span class="o">=</span> <span class="p">[</span><span class="n">cid</span> <span class="k">for</span> <span class="n">cid</span> <span class="ow">in</span> <span class="n">unique_cells</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_indices</span><span class="p">(</span><span class="n">cid</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">]</span>
                <span class="n">invalid_cells</span> <span class="o">=</span> <span class="p">[</span><span class="n">cid</span> <span class="k">for</span> <span class="n">cid</span> <span class="ow">in</span> <span class="n">unique_cells</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_indices</span><span class="p">(</span><span class="n">cid</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">]</span>
                
                <span class="k">for</span> <span class="n">geometry</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">polygon_json</span><span class="p">[</span><span class="s1">&#39;geometries&#39;</span><span class="p">],</span> <span class="n">disable</span><span class="o">=</span><span class="n">disable_tqdm</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">geometry</span> <span class="ow">and</span> <span class="n">geometry</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Polygon&#39;</span><span class="p">:</span>
                        <span class="n">polygon</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">geometry</span><span class="p">[</span><span class="s1">&#39;coordinates&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">cell_polygons</span><span class="p">[</span><span class="n">valid_cells</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="n">polygon</span>
                    <span class="k">elif</span> <span class="ow">not</span> <span class="n">geometry</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">cell_polygons</span><span class="p">[</span><span class="n">invalid_cells</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="n">geometry</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;geojson type must be FeatureCollection or GeometryCollection&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">pickle</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">load_path</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cell_polygons</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">))</span></div>


    
<div class="viewcode-block" id="SpotTable.cell_indices">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.cell_indices">[docs]</a>
    <span class="k">def</span> <span class="nf">cell_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell_ids</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return indices giving table location of all spots with *cell_ids*</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cell_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cid</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_ids</span><span class="p">):</span>
                <span class="n">ind</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">cid</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cell_index</span> <span class="o">=</span> <span class="n">ind</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cell_ids</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cell_index</span><span class="p">[</span><span class="n">cell_ids</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cell_ids</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cell_index</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_cell_id</span><span class="p">(</span><span class="n">cell_ids</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell_ids</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cell_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">cell_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pcid_to_cid</span><span class="o">.</span><span class="n">get</span><span class="p">)(</span><span class="n">cell_ids</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_cell_index</span><span class="p">[</span><span class="n">cid</span><span class="p">]</span> <span class="k">for</span> <span class="n">cid</span> <span class="ow">in</span> <span class="n">cell_ids</span><span class="p">])</span></div>


<div class="viewcode-block" id="SpotTable.cells_inside_region">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.cells_inside_region">[docs]</a>
    <span class="k">def</span> <span class="nf">cells_inside_region</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xlim</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">ylim</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return IDs of cells that are entirely inside xlim, ylim.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cell_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cid</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_ids</span><span class="p">):</span>
            <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_bounds</span><span class="p">(</span><span class="n">cid</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x0</span> <span class="o">&gt;</span> <span class="n">xlim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">x1</span> <span class="o">&lt;</span> <span class="n">xlim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">y0</span> <span class="o">&gt;</span> <span class="n">ylim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">y1</span> <span class="o">&lt;</span> <span class="n">ylim</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">cell_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cell_ids</span></div>


<div class="viewcode-block" id="SpotTable.cell_mask">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.cell_mask">[docs]</a>
    <span class="k">def</span> <span class="nf">cell_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell_ids</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a mask selecting spots that belong to cells in *cell_ids*</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">cell_ids</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="n">mask</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_indices</span><span class="p">(</span><span class="n">cell_ids</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cell_ids</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">mask</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_cell_id</span><span class="p">(</span><span class="n">cell_ids</span><span class="p">))]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cell_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">cell_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pcid_to_cid</span><span class="o">.</span><span class="n">get</span><span class="p">)(</span><span class="n">cell_ids</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">cid</span> <span class="ow">in</span> <span class="n">cell_ids</span><span class="p">:</span>
                <span class="n">mask</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_indices</span><span class="p">(</span><span class="n">cid</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">mask</span></div>


<div class="viewcode-block" id="SpotTable.gene_indices">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.gene_indices">[docs]</a>
    <span class="k">def</span> <span class="nf">gene_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gene_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gene_ids</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return an array of indices where the detected transcript is in either gene_names or gene_ids</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">gene_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">gene_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gene_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">gene_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_gene_names_to_ids</span><span class="p">(</span><span class="n">gene_names</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gene_ids</span><span class="p">,</span> <span class="n">gene_ids</span><span class="p">))[:,</span> <span class="mi">0</span><span class="p">]</span></div>

    
<div class="viewcode-block" id="SpotTable.map_indices_to_parent">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.map_indices_to_parent">[docs]</a>
    <span class="k">def</span> <span class="nf">map_indices_to_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inds</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Given an array of indices into this SpotTable, return a new array of indices that</span>
<span class="sd">        select the same spots in the parent SpotTable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_inds</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span></div>

    
<div class="viewcode-block" id="SpotTable.map_indices_from_parent">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.map_indices_from_parent">[docs]</a>
    <span class="k">def</span> <span class="nf">map_indices_from_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inds</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Given an array of indices into the parent SpotTable, return a new array of indices that</span>
<span class="sd">        select the same spots in this SpotTable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inv_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">b</span><span class="p">:</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent_inds</span><span class="p">)}</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">inv_map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inds</span><span class="p">])</span></div>

    
<div class="viewcode-block" id="SpotTable.map_mask_to_parent">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.map_mask_to_parent">[docs]</a>
    <span class="k">def</span> <span class="nf">map_mask_to_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Given a boolean mask that selects spots from this SpotTable, return a new boolean mask</span>
<span class="sd">        that selects the same spots from the parent SpotTable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parent_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent_table</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">parent_mask</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parent_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask</span>
        <span class="k">return</span> <span class="n">parent_mask</span></div>

    
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="nb">int</span><span class="o">|</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a subset of this SpotTable.</span>

<span class="sd">        *item* may be an integer array of indices to select, or a boolean mask array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
        <span class="n">gene_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gene_ids</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
        <span class="n">cell_ids</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_ids</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_ids</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
        <span class="n">production_cell_ids</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">production_cell_ids</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">production_cell_ids</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
         <span class="c1"># cell_polygons is not converted because we cannot guarantee the polygons will stay the same after subsetting</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">parent_region</span> <span class="o">=</span> <span class="p">((</span><span class="n">pos</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">pos</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()),</span> <span class="p">(</span><span class="n">pos</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">pos</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">parent_region</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">subset</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span>
            <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span>
            <span class="n">gene_ids</span><span class="o">=</span><span class="n">gene_ids</span><span class="p">,</span>
            <span class="n">gene_id_to_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gene_id_to_name</span><span class="p">,</span>
            <span class="n">cell_ids</span><span class="o">=</span><span class="n">cell_ids</span><span class="p">,</span> 
            <span class="n">production_cell_ids</span><span class="o">=</span><span class="n">production_cell_ids</span><span class="p">,</span> 
            <span class="n">pcid_to_cid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_pcid_to_cid</span><span class="p">,</span>
            <span class="n">cid_to_pcid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cid_to_pcid</span><span class="p">,</span>
            <span class="n">parent_table</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> 
            <span class="n">parent_inds</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))[</span><span class="n">item</span><span class="p">],</span>
            <span class="n">parent_region</span><span class="o">=</span><span class="n">parent_region</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">subset</span><span class="o">.</span><span class="n">images</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">images</span><span class="p">[:]</span>
            
        <span class="k">return</span> <span class="n">subset</span>
    
<div class="viewcode-block" id="SpotTable.copy">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.copy">[docs]</a>
    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a copy of self, optionally with some attributes replaced.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">init_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">parent_table</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent_table</span><span class="p">,</span>
            <span class="n">parent_inds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent_inds</span><span class="p">,</span>
            <span class="n">parent_region</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent_region</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">init_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwds</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;pos&#39;</span><span class="p">,</span> <span class="s1">&#39;gene_ids&#39;</span><span class="p">,</span> <span class="s1">&#39;gene_id_to_name&#39;</span><span class="p">,</span> <span class="s1">&#39;cell_ids&#39;</span><span class="p">,</span> <span class="s1">&#39;production_cell_ids&#39;</span><span class="p">,</span> <span class="s1">&#39;_pcid_to_cid&#39;</span><span class="p">,</span> <span class="s1">&#39;_cid_to_pcid&#39;</span><span class="p">,</span> <span class="s1">&#39;images&#39;</span><span class="p">,</span> <span class="s1">&#39;cell_polygons&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">init_kwargs</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">deep</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">val</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">):</span> <span class="c1"># This is to handle _pcid_to_cid and _cid_to_pcid as arguments</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="n">init_kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
            
        <span class="k">return</span> <span class="n">SpotTable</span><span class="p">(</span><span class="o">**</span><span class="n">init_kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpotTable.split_tiles">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.split_tiles">[docs]</a>
    <span class="k">def</span> <span class="nf">split_tiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_spots_per_tile</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target_tile_width</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overlap</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">incl_end</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a list of SpotTables that tile this one.</span>

<span class="sd">        This table will be split into rows of equal height, and each row will be split into</span>
<span class="sd">        columns with roughly the same number of spots (less than *max_spots_per_tile*).</span>
<span class="sd">        </span>
<span class="sd">        see also: grid_tiles</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        max_spots_per_tile : int | None</span>
<span class="sd">            Maximum number of spots to include in each tile.</span>
<span class="sd">        target_tile_width : float | None</span>
<span class="sd">            Automatically select max_spots_per_tile to get an approximate tile width</span>
<span class="sd">        overlap : float</span>
<span class="sd">            Distance to overlap tiles</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">max_spots_per_tile</span> <span class="o">==</span> <span class="kc">None</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">target_tile_width</span> <span class="o">==</span> <span class="kc">None</span><span class="p">),</span> <span class="s2">&quot;Must specify either max_spots_per_tile or target_tile_width&quot;</span>

        <span class="k">if</span> <span class="n">max_spots_per_tile</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># convert target_tile_width to max_spots_per_tile</span>
            <span class="n">x_range</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">target_n_cols</span> <span class="o">=</span> <span class="n">x_range</span> <span class="o">/</span> <span class="n">target_tile_width</span>
            <span class="n">max_spots_per_tile</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">/</span> <span class="n">target_n_cols</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">max_spots_per_tile</span> <span class="o">*=</span> <span class="mf">1.2</span> <span class="o">*</span> <span class="p">(</span><span class="n">target_tile_width</span> <span class="o">+</span> <span class="n">overlap</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">target_tile_width</span><span class="o">**</span><span class="mi">2</span>

        <span class="n">max_spots_per_tile</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_spots_per_tile</span><span class="p">)</span>
        <span class="n">padding</span> <span class="o">=</span> <span class="n">overlap</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">est_n_tiles</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">//</span> <span class="n">max_spots_per_tile</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">()</span>
        <span class="n">tot_width</span><span class="p">,</span> <span class="n">tot_height</span> <span class="o">=</span> <span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">aspect_ratio</span> <span class="o">=</span> <span class="n">tot_width</span> <span class="o">/</span> <span class="n">tot_height</span>
        <span class="n">est_n_cols</span> <span class="o">=</span> <span class="n">est_n_tiles</span> <span class="o">**</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">aspect_ratio</span>
        <span class="n">n_rows</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">est_n_tiles</span> <span class="o">/</span> <span class="n">est_n_cols</span><span class="p">))</span>
        <span class="n">tile_height</span> <span class="o">=</span> <span class="n">tot_height</span> <span class="o">/</span> <span class="n">n_rows</span>

        <span class="n">tiles</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_rows</span><span class="p">)):</span>
            <span class="c1"># get a subregion for the entire row</span>
            <span class="n">start_y</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">row</span> <span class="o">*</span> <span class="n">tile_height</span>
            <span class="n">stop_y</span> <span class="o">=</span> <span class="n">start_y</span> <span class="o">+</span> <span class="n">tile_height</span>
            <span class="n">row_table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_subregion</span><span class="p">(</span>
                <span class="n">xlim</span><span class="o">=</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">ylim</span><span class="o">=</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">start_y</span> <span class="o">-</span> <span class="n">padding</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">stop_y</span> <span class="o">+</span> <span class="n">padding</span><span class="p">)),</span>
                <span class="n">incl_end</span><span class="o">=</span><span class="n">incl_end</span><span class="p">)</span>
            <span class="n">row_bounds</span> <span class="o">=</span> <span class="n">row_table</span><span class="o">.</span><span class="n">bounds</span><span class="p">()</span>

            <span class="c1"># sort x values</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">row_table</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
            <span class="n">xvals</span> <span class="o">=</span> <span class="n">row_table</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>

            <span class="c1"># split into columns</span>
            <span class="n">n_cols</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">row_table</span><span class="p">)</span> <span class="o">//</span> <span class="n">max_spots_per_tile</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="c1"># iteratively attempt smaller columns until everything fits</span>
                <span class="n">init_spots_per_col</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">row_table</span><span class="p">)</span> <span class="o">//</span> <span class="n">n_cols</span>
                <span class="n">cols</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">failed</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_cols</span><span class="p">):</span>
                    <span class="c1"># start with equal chunks of data</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="n">col</span> <span class="o">*</span> <span class="n">init_spots_per_col</span>
                    <span class="n">stop</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">init_spots_per_col</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">row_table</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

                    <span class="c1"># adjust start / stop to account for padding</span>
                    <span class="n">padded_start_x</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">xvals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xvals</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">-</span> <span class="n">padding</span><span class="p">)</span>
                    <span class="n">padded_stop_x</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">xvals</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">xvals</span><span class="p">[</span><span class="n">stop</span><span class="p">]</span> <span class="o">+</span> <span class="n">padding</span><span class="p">)</span>
                    <span class="n">start_adj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">padded_start_x</span><span class="p">)</span>
                    <span class="n">stop_adj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">padded_stop_x</span><span class="p">)</span>

                    <span class="c1"># create the tile</span>
                    <span class="n">tile_inds</span> <span class="o">=</span> <span class="n">order</span><span class="p">[</span><span class="n">start_adj</span><span class="p">:</span><span class="n">stop_adj</span><span class="p">]</span>
                    <span class="n">tile</span> <span class="o">=</span> <span class="n">row_table</span><span class="p">[</span><span class="n">tile_inds</span><span class="p">]</span>

                    <span class="c1"># re-parent tile to self rather than row_table</span>
                    <span class="n">tile</span><span class="o">.</span><span class="n">parent_region</span> <span class="o">=</span> <span class="p">((</span><span class="n">padded_start_x</span><span class="p">,</span> <span class="n">padded_stop_x</span><span class="p">),</span> <span class="n">row_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">tile</span><span class="o">.</span><span class="n">parent_table</span> <span class="o">=</span> <span class="bp">self</span>
                    <span class="n">tile</span><span class="o">.</span><span class="n">parent_inds</span> <span class="o">=</span> <span class="n">row_table</span><span class="o">.</span><span class="n">map_indices_to_parent</span><span class="p">(</span><span class="n">tile_inds</span><span class="p">)</span>

                    <span class="c1"># if this tile is too big, then start the row over with smaller tiles</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tile</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_spots_per_tile</span><span class="p">:</span>
                        <span class="n">failed</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>
                    <span class="n">cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tile</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">failed</span><span class="p">:</span>
                    <span class="n">n_cols</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="n">tiles</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tiles</span></div>


<div class="viewcode-block" id="SpotTable.grid_tiles">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.grid_tiles">[docs]</a>
    <span class="k">def</span> <span class="nf">grid_tiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_tile_size</span><span class="p">:</span><span class="nb">float</span><span class="p">,</span> <span class="n">overlap</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">incl_end</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a grid of overlapping tiles with equal size, where the width and height</span>
<span class="sd">        must be less than max_tile_size.</span>

<span class="sd">        See also: split_tiles</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">max_tile_size</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">overlap</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">()</span>
        <span class="n">width</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">height</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">n_cols</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">width</span> <span class="o">/</span> <span class="n">max_tile_size</span><span class="p">)</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">n_cols</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">col_width</span> <span class="o">=</span> <span class="p">(</span><span class="n">width</span> <span class="o">+</span> <span class="p">(</span><span class="n">n_cols</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">overlap</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_cols</span>
            <span class="k">if</span> <span class="n">col_width</span> <span class="o">&lt;=</span> <span class="n">max_tile_size</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="n">n_rows</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">height</span> <span class="o">/</span> <span class="n">max_tile_size</span><span class="p">)</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">n_rows</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">row_height</span> <span class="o">=</span> <span class="p">(</span><span class="n">height</span> <span class="o">+</span> <span class="p">(</span><span class="n">n_rows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">overlap</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_rows</span>
            <span class="k">if</span> <span class="n">row_height</span> <span class="o">&lt;=</span> <span class="n">max_tile_size</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="n">tiles</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_rows</span><span class="p">)):</span>
            <span class="n">ystart</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">row</span> <span class="o">*</span> <span class="p">(</span><span class="n">row_height</span> <span class="o">-</span> <span class="n">overlap</span><span class="p">)</span>
            <span class="n">ylim</span> <span class="o">=</span> <span class="p">(</span><span class="n">ystart</span><span class="p">,</span> <span class="n">ystart</span> <span class="o">+</span> <span class="n">row_height</span><span class="p">)</span>
            <span class="n">row_tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_subregion</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ylim</span><span class="p">,</span> <span class="n">incl_end</span><span class="o">=</span><span class="n">incl_end</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_cols</span><span class="p">):</span>
                <span class="n">xstart</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">col</span> <span class="o">*</span> <span class="p">(</span><span class="n">col_width</span> <span class="o">-</span> <span class="n">overlap</span><span class="p">)</span>
                <span class="n">xlim</span> <span class="o">=</span> <span class="p">(</span><span class="n">xstart</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">xstart</span> <span class="o">+</span> <span class="n">col_width</span><span class="p">,</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">tile</span> <span class="o">=</span> <span class="n">row_tile</span><span class="o">.</span><span class="n">get_subregion</span><span class="p">(</span><span class="n">xlim</span><span class="p">,</span> <span class="n">ylim</span><span class="p">,</span> <span class="n">incl_end</span><span class="o">=</span><span class="n">incl_end</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tile</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">tiles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tile</span><span class="p">)</span>
                <span class="c1"># re-parent tile to self rather than row_table</span>
                <span class="n">tile</span><span class="o">.</span><span class="n">parent_table</span> <span class="o">=</span> <span class="bp">self</span>
                <span class="n">tile</span><span class="o">.</span><span class="n">parent_inds</span> <span class="o">=</span> <span class="n">row_tile</span><span class="o">.</span><span class="n">map_indices_to_parent</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">parent_inds</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tiles</span></div>


<div class="viewcode-block" id="SpotTable.cell_indices_within_padding">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.cell_indices_within_padding">[docs]</a>
    <span class="k">def</span> <span class="nf">cell_indices_within_padding</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mf">5.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return spot indices all cells that do not come within *padding* of the parent_region.</span>

<span class="sd">        This is used to exclude cells near the edge of a tile, where the segmentation becomes unreliable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tile_xlim</span><span class="p">,</span> <span class="n">tile_ylim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_region</span>
        <span class="n">include_xlim</span> <span class="o">=</span> <span class="p">(</span><span class="n">tile_xlim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">padding</span><span class="p">,</span> <span class="n">tile_xlim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">padding</span><span class="p">)</span> 
        <span class="n">include_ylim</span> <span class="o">=</span> <span class="p">(</span><span class="n">tile_ylim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">padding</span><span class="p">,</span> <span class="n">tile_ylim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">padding</span><span class="p">)</span> 
        <span class="n">include_cells</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells_inside_region</span><span class="p">(</span><span class="n">xlim</span><span class="o">=</span><span class="n">include_xlim</span><span class="p">,</span> <span class="n">ylim</span><span class="o">=</span><span class="n">include_ylim</span><span class="p">)</span>
        <span class="n">include_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_indices</span><span class="p">(</span><span class="n">include_cells</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">include_inds</span></div>


<div class="viewcode-block" id="SpotTable.merge_cells">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.merge_cells">[docs]</a>
    <span class="k">def</span> <span class="nf">merge_cells</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Merge cell IDs from SpotTable *other* into self.</span>

<span class="sd">        Returns a structure describing merge conflicts.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># copy *other* because we will modify cell IDs</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">cell_ids</span><span class="o">=</span><span class="n">other</span><span class="o">.</span><span class="n">cell_ids</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="c1"># increment cell IDs in new tile (leaving cell 0 unchanged)</span>
        <span class="n">other</span><span class="o">.</span><span class="n">cell_ids</span><span class="p">[</span><span class="n">other</span><span class="o">.</span><span class="n">cell_ids</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_ids</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">other</span><span class="o">.</span><span class="n">cell_ids_changed</span><span class="p">()</span>

        <span class="c1"># get indices of all cells that are not close to the edge of the tile partial cells from edge of tile</span>
        <span class="n">tile_inds</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">cell_indices_within_padding</span><span class="p">(</span><span class="n">padding</span><span class="o">=</span><span class="n">padding</span><span class="p">)</span>
        <span class="n">self_inds</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">map_indices_to_parent</span><span class="p">(</span><span class="n">tile_inds</span><span class="p">)</span>

        <span class="c1"># keep track of state before merge so we can look for conflicts afterward</span>
        <span class="n">original_state</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">other</span><span class="o">.</span><span class="n">parent_inds</span><span class="p">]</span>

        <span class="c1"># copy all retained cells from first tile to full table</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cell_ids</span><span class="p">[</span><span class="n">self_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">cell_ids</span><span class="p">[</span><span class="n">tile_inds</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cell_ids_changed</span><span class="p">()</span>

        <span class="c1"># At this point the merge is done</span>
        <span class="c1"># ------------------------------- </span>
        <span class="c1"># the rest is just collecting information about possible merge conflicts</span>
        <span class="n">new_state</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">other</span><span class="o">.</span><span class="n">parent_inds</span><span class="p">]</span>

        <span class="c1"># cells in original state that were affected by merge</span>
        <span class="n">affected_cell_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">original_state</span><span class="o">.</span><span class="n">cell_ids</span><span class="p">[</span><span class="n">tile_inds</span><span class="p">])</span> <span class="o">-</span> <span class="nb">set</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="c1"># all cells present in new merge area</span>
        <span class="n">new_cell_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">new_state</span><span class="o">.</span><span class="n">cell_ids</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="c1"># set of cells that were partially replaced by the merge</span>
        <span class="c1"># (cells that were affected by the merge, but not completely replaced by the merge)</span>
        <span class="n">partial_merge_cells</span> <span class="o">=</span> <span class="n">new_cell_ids</span> <span class="o">&amp;</span> <span class="n">affected_cell_ids</span>

        <span class="n">conflicts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="n">partial_merge_cells</span><span class="p">:</span>
            <span class="n">old_inds</span> <span class="o">=</span> <span class="n">original_state</span><span class="o">.</span><span class="n">cell_indices</span><span class="p">(</span><span class="n">cell_id</span><span class="p">)</span>
            <span class="n">new_inds</span> <span class="o">=</span> <span class="n">new_state</span><span class="o">.</span><span class="n">cell_indices</span><span class="p">(</span><span class="n">cell_id</span><span class="p">)</span>

            <span class="c1"># which new cells replaced part of the old cell?</span>
            <span class="n">overlapped_cells</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">new_state</span><span class="o">.</span><span class="n">cell_ids</span><span class="p">[</span><span class="n">old_inds</span><span class="p">])</span> <span class="o">-</span> <span class="nb">set</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">overlapped_cell_inds</span> <span class="o">=</span> <span class="p">{</span><span class="n">cid</span><span class="p">:</span><span class="n">new_state</span><span class="o">.</span><span class="n">cell_indices</span><span class="p">(</span><span class="n">cid</span><span class="p">)</span> <span class="k">for</span> <span class="n">cid</span> <span class="ow">in</span> <span class="n">overlapped_cells</span><span class="p">}</span>

            <span class="c1"># how big are the overlapping cells?</span>
            <span class="n">original_cell_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">old_inds</span><span class="p">)</span>
            <span class="n">reduced_cell_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_inds</span><span class="p">)</span>
            <span class="n">overlapped_cell_sizes</span> <span class="o">=</span> <span class="p">{</span><span class="n">cid</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span> <span class="k">for</span> <span class="n">cid</span><span class="p">,</span> <span class="n">inds</span> <span class="ow">in</span> <span class="n">overlapped_cell_inds</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="n">overlapped_cell_parent_inds</span> <span class="o">=</span> <span class="p">{</span><span class="n">cid</span><span class="p">:</span><span class="n">new_state</span><span class="o">.</span><span class="n">map_indices_to_parent</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span> <span class="k">for</span> <span class="n">cid</span><span class="p">,</span> <span class="n">inds</span> <span class="ow">in</span> <span class="n">overlapped_cell_inds</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

            <span class="n">conflicts</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                <span class="s1">&#39;original_cell_id&#39;</span><span class="p">:</span> <span class="n">cell_id</span><span class="p">,</span>
                <span class="s1">&#39;original_size&#39;</span><span class="p">:</span> <span class="n">original_cell_size</span><span class="p">,</span>
                <span class="s1">&#39;size_after_merge&#39;</span><span class="p">:</span> <span class="n">reduced_cell_size</span><span class="p">,</span>
                <span class="s1">&#39;size_ratio&#39;</span><span class="p">:</span> <span class="n">reduced_cell_size</span> <span class="o">/</span> <span class="n">original_cell_size</span><span class="p">,</span>
                <span class="s1">&#39;original_indices&#39;</span><span class="p">:</span> <span class="n">new_state</span><span class="o">.</span><span class="n">map_indices_to_parent</span><span class="p">(</span><span class="n">old_inds</span><span class="p">),</span>
                <span class="s1">&#39;overlapped_cells&#39;</span><span class="p">:</span> <span class="n">overlapped_cells</span><span class="p">,</span>
                <span class="s1">&#39;overlapped_cell_sizes&#39;</span><span class="p">:</span> <span class="n">overlapped_cell_sizes</span><span class="p">,</span>
                <span class="s1">&#39;overlapped_cell_indices&#39;</span><span class="p">:</span> <span class="n">overlapped_cell_parent_inds</span><span class="p">,</span>
            <span class="p">})</span>

        <span class="k">return</span> <span class="n">conflicts</span></div>


<div class="viewcode-block" id="SpotTable.set_cell_ids_from_tiles">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.set_cell_ids_from_tiles">[docs]</a>
    <span class="k">def</span> <span class="nf">set_cell_ids_from_tiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tiles</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Overwrite all cell IDs by merging from *tiles*, which may be a list of SpotTable</span>
<span class="sd">        or SegmentationResult instances.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.segmentation</span> <span class="kn">import</span> <span class="n">SegmentationResult</span>
        <span class="c1"># create empty cell ID table (where -1 means nothing has been assigned yet)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cell_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cell_ids</span><span class="p">[:]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">merge_results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">tile</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">tiles</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tile</span><span class="p">,</span> <span class="n">SegmentationResult</span><span class="p">):</span>
                <span class="n">tile</span> <span class="o">=</span> <span class="n">tile</span><span class="o">.</span><span class="n">spot_table</span><span class="p">()</span>            
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_cells</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">padding</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
            <span class="n">merge_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">merge_results</span></div>


<div class="viewcode-block" id="SpotTable.plot_rect">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.plot_rect">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_rect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot the bounding region of this table as a rectangle.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">matplotlib.patches</span>
        <span class="n">xlim</span><span class="p">,</span> <span class="n">ylim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_region</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">xlim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ylim</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">width</span> <span class="o">=</span> <span class="n">xlim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">xlim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">height</span> <span class="o">=</span> <span class="n">ylim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ylim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">rect</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">patches</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">rect</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rect</span></div>

    
<div class="viewcode-block" id="SpotTable.cell_palette">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.cell_palette">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">cell_palette</span><span class="p">(</span><span class="n">cells</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate a color palette suitable for distinguisging individual cells</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">seaborn</span>
        <span class="n">cell_set</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cells</span><span class="p">)</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="n">seaborn</span><span class="o">.</span><span class="n">color_palette</span><span class="p">(</span><span class="s1">&#39;tab20b&#39;</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
        <span class="n">palette</span> <span class="o">=</span> <span class="p">{</span><span class="n">cid</span><span class="p">:</span> <span class="n">colors</span><span class="p">[</span><span class="n">i</span><span class="o">%</span><span class="nb">len</span><span class="p">(</span><span class="n">colors</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cid</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cell_set</span><span class="p">)}</span>
        <span class="n">palette</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">)</span>
        <span class="n">palette</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">)</span>
        <span class="n">palette</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">palette</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">palette</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">palette</span><span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">palette</span></div>


<div class="viewcode-block" id="SpotTable.scatter_plot">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.scatter_plot">[docs]</a>
    <span class="k">def</span> <span class="nf">scatter_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;gene_ids&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">z_slice</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">seaborn</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">z_slice</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">zvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
            <span class="n">zval</span> <span class="o">=</span> <span class="n">zvals</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">z_slice</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">zvals</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))]</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">==</span> <span class="n">zval</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
            
        <span class="k">if</span> <span class="n">color</span> <span class="o">==</span> <span class="s1">&#39;cell&#39;</span><span class="p">:</span> 
            <span class="n">palette</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_palette</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_ids</span><span class="p">)</span>
            <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;cell_ids&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">palette</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">seaborn</span><span class="o">.</span><span class="n">scatterplot</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dataframe</span><span class="p">(</span><span class="n">cols</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">color</span><span class="p">]),</span>
            <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> 
            <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> 
            <span class="n">hue</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> 
            <span class="n">palette</span><span class="o">=</span><span class="n">palette</span><span class="p">,</span>
            <span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> 
            <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
            <span class="n">s</span><span class="o">=</span><span class="n">size</span><span class="p">,</span>
            <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
            <span class="n">legend</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpotTable.cell_scatter_plot">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.cell_scatter_plot">[docs]</a>
    <span class="k">def</span> <span class="nf">cell_scatter_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Scatter plot of spots colored by cell ID</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwds</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;cell&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">scatter_plot</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpotTable.binned_expression_counts">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.binned_expression_counts">[docs]</a>
    <span class="k">def</span> <span class="nf">binned_expression_counts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">binsize</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return an array of spatially binned gene expression counts with shape (n_x_bins, n_y_bins, n_genes)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span>
        <span class="n">gene</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gene_ids</span>
        
        <span class="n">xrange</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">yrange</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        
        <span class="n">gene_id_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gene_id_to_name</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">x_bins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">xrange</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">xrange</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">binsize</span><span class="p">))</span>
        <span class="n">y_bins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">yrange</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">yrange</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">binsize</span><span class="p">))</span>
        
        <span class="n">hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogramdd</span><span class="p">(</span>
            <span class="n">sample</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">gene</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
            <span class="n">bins</span><span class="o">=</span><span class="p">(</span><span class="n">x_bins</span><span class="p">,</span> <span class="n">y_bins</span><span class="p">,</span> <span class="n">gene_id_bins</span><span class="p">),</span>
        <span class="p">)</span>
                    
        <span class="k">return</span> <span class="n">hist</span></div>

    
<div class="viewcode-block" id="SpotTable.reduced_expression_map">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.reduced_expression_map">[docs]</a>
    <span class="k">def</span> <span class="nf">reduced_expression_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">binsize</span><span class="p">,</span> <span class="n">umap_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">umap_ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">util</span><span class="o">.</span><span class="n">log_plus_1</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">seaborn</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">umap_args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">umap_args</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="n">min_dist</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span>
                <span class="n">n_neighbors</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Binning expression counts..&quot;</span><span class="p">)</span>
        <span class="n">bec</span><span class="p">,</span> <span class="p">(</span><span class="n">xbins</span><span class="p">,</span> <span class="n">ybins</span><span class="p">,</span> <span class="n">gbins</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_expression_counts</span><span class="p">(</span><span class="n">binsize</span><span class="o">=</span><span class="n">binsize</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Reducing binned expression counts..&quot;</span><span class="p">)</span>
        <span class="n">umap_args</span><span class="p">[</span><span class="s1">&#39;n_components&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">norm_bec</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">bec</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">norm_bec</span> <span class="o">=</span> <span class="n">bec</span>
        <span class="n">reduced</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">reduce_expression</span><span class="p">(</span><span class="n">norm_bec</span><span class="p">,</span> <span class="n">umap_args</span><span class="o">=</span><span class="n">umap_args</span><span class="p">)</span>
        
        <span class="n">norm</span> <span class="o">=</span> <span class="n">bec</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">norm</span> <span class="o">/</span> <span class="n">norm</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">color</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">rainbow_wheel</span><span class="p">(</span><span class="n">reduced</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">norm</span><span class="p">[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">])</span>
        
        <span class="n">xrange</span> <span class="o">=</span> <span class="n">xbins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xbins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">yrange</span> <span class="o">=</span> <span class="n">ybins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ybins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">util</span><span class="o">.</span><span class="n">show_float_rgb</span><span class="p">(</span><span class="n">color</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">extent</span><span class="o">=</span><span class="n">xrange</span> <span class="o">+</span> <span class="n">yrange</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">umap_ax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">flat</span> <span class="o">=</span> <span class="n">reduced</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">reduced</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">reduced</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reduced</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">color</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">rainbow_wheel</span><span class="p">(</span><span class="n">flat</span><span class="p">)</span>
            <span class="n">seaborn</span><span class="o">.</span><span class="n">scatterplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">flat</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span><span class="o">=</span><span class="n">flat</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">umap_ax</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">bec</span><span class="p">,</span> <span class="p">(</span><span class="n">xbins</span><span class="p">,</span> <span class="n">ybins</span><span class="p">,</span> <span class="n">gbins</span><span class="p">),</span> <span class="p">(</span><span class="n">reduced</span><span class="p">,)</span></div>


<div class="viewcode-block" id="SpotTable.show_binned_heatmap">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.show_binned_heatmap">[docs]</a>
    <span class="k">def</span> <span class="nf">show_binned_heatmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">image_size</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Show an image of binned spot positions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xbins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">image_size</span><span class="p">)</span>
        <span class="n">ybins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">image_size</span><span class="p">)</span>
        <span class="n">hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="p">[</span><span class="n">xbins</span><span class="p">,</span> <span class="n">ybins</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">hist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">hist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;equal&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;inferno&#39;</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="n">xbins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xbins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">ybins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ybins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span></div>


<div class="viewcode-block" id="SpotTable.show_subregion_images">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.show_subregion_images">[docs]</a>
    <span class="k">def</span> <span class="nf">show_subregion_images</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subtables</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Show a spot table image and successive subregions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">subtables</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">table</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tables</span><span class="p">):</span>
            <span class="n">table</span><span class="o">.</span><span class="n">show_image</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">table</span><span class="o">.</span><span class="n">plot_rect</span><span class="p">(</span><span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;c&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpotTable.add_image">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.add_image">[docs]</a>
    <span class="k">def</span> <span class="nf">add_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attach an image to this dataset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">image</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="n">img</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">img</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">images</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;An image named </span><span class="si">{</span><span class="n">image</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> is already attached&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">images</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">image</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpotTable.get_image">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.get_image">[docs]</a>
    <span class="k">def</span> <span class="nf">get_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">channel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the image with the given name or channel name</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">selected</span> <span class="o">=</span> <span class="p">[</span><span class="n">img</span> <span class="k">for</span> <span class="n">img</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">images</span> <span class="k">if</span> <span class="n">img</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">name</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No image found with name=</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">channel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">selected</span> <span class="o">=</span> <span class="p">[</span><span class="n">img</span> <span class="k">for</span> <span class="n">img</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">images</span> <span class="k">if</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">img</span><span class="o">.</span><span class="n">channels</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No image found with channel </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Multiple images found with channel </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Must specify at least one of name or channel&quot;</span><span class="p">)</span>
        <span class="n">selected_img</span> <span class="o">=</span> <span class="n">selected</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            
        <span class="k">if</span> <span class="n">channel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">selected_img</span> <span class="o">=</span> <span class="n">selected_img</span><span class="o">.</span><span class="n">get_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">frame</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">selected_img</span> <span class="o">=</span> <span class="n">selected_img</span><span class="o">.</span><span class="n">get_frame</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">selected_img</span>            </div>

        
<div class="viewcode-block" id="SpotTable.show_image">
<a class="viewcode-back" href="../../sis.html#sis.spot_table.SpotTable.show_image">[docs]</a>
    <span class="k">def</span> <span class="nf">show_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">channel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">z_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">z_pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Show a channel / z plane from an image</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_image</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">channel</span><span class="o">=</span><span class="n">channel</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">z_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">get_z_index</span><span class="p">(</span><span class="n">z_index</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">z_pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">get_z_pos</span><span class="p">(</span><span class="n">z_pos</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">img</span></div>
</div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">Spots-in-Spaaaaaace!</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, Allen Spatial Analysis Working Group.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
    </div>

    

    
  </body>
</html>