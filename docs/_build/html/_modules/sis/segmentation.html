<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>sis.segmentation &#8212; Spots-in-Spaaaaaace! 0.0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=12dfc556" />
    <script src="../../_static/documentation_options.js?v=d45e8c67"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for sis.segmentation</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>
<span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">tempfile</span><span class="o">,</span> <span class="nn">pickle</span><span class="o">,</span> <span class="nn">traceback</span>
<span class="kn">import</span> <span class="nn">scipy.ndimage</span><span class="o">,</span> <span class="nn">scipy.interpolate</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">tqdm.autonotebook</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">from</span> <span class="nn">.hpc</span> <span class="kn">import</span> <span class="n">run_slurm_func</span>
<span class="kn">from</span> <span class="nn">.spot_table</span> <span class="kn">import</span> <span class="n">SpotTable</span>
<span class="kn">from</span> <span class="nn">.image</span> <span class="kn">import</span> <span class="n">Image</span><span class="p">,</span> <span class="n">ImageBase</span><span class="p">,</span> <span class="n">ImageTransform</span>

<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span><span class="p">,</span> <span class="n">PurePath</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">abstractmethod</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">anndata</span> <span class="k">as</span> <span class="nn">ad</span>
<span class="kn">import</span> <span class="nn">sis</span>


<div class="viewcode-block" id="run_segmentation">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.run_segmentation">[docs]</a>
<span class="k">def</span> <span class="nf">run_segmentation</span><span class="p">(</span><span class="n">load_func</span><span class="p">,</span> <span class="n">load_args</span><span class="p">:</span><span class="nb">dict</span><span class="p">,</span> <span class="n">subregion</span><span class="p">:</span><span class="nb">dict</span><span class="o">|</span><span class="kc">None</span><span class="p">,</span> <span class="n">method_class</span><span class="p">,</span> <span class="n">method_args</span><span class="p">:</span><span class="nb">dict</span><span class="p">,</span> <span class="n">result_file</span><span class="p">:</span><span class="nb">str</span><span class="o">|</span><span class="kc">None</span><span class="p">,</span> <span class="n">cell_id_file</span><span class="p">:</span><span class="nb">str</span><span class="o">|</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Load a spot table, run segmentation (possibly on a subregion), and save the SegmentationResult.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">spot_table</span> <span class="o">=</span> <span class="n">load_func</span><span class="p">(</span><span class="o">**</span><span class="n">load_args</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;loaded spot table </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">spot_table</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">subregion</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">spot_table</span> <span class="o">=</span> <span class="n">spot_table</span><span class="o">.</span><span class="n">get_subregion</span><span class="p">(</span><span class="o">*</span><span class="n">subregion</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;subregion </span><span class="si">{</span><span class="n">subregion</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">spot_table</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">seg</span> <span class="o">=</span> <span class="n">method_class</span><span class="p">(</span><span class="o">**</span><span class="n">method_args</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">seg</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">spot_table</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cell_ids </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">cell_ids</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">result_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">result</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">result_file</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;saved segmentation result to </span><span class="si">{</span><span class="n">result_file</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cell_id_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">cell_id_file</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">cell_ids</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;saved segmentated cell IDs to </span><span class="si">{</span><span class="n">cell_id_file</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="SegmentationResult">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.SegmentationResult">[docs]</a>
<span class="k">class</span> <span class="nc">SegmentationResult</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Represents a segmentation of SpotTable data--method, options, results</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span><span class="s1">&#39;SegmentationMethod&#39;</span><span class="p">,</span> <span class="n">input_spot_table</span><span class="p">:</span><span class="n">SpotTable</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_spot_table</span> <span class="o">=</span> <span class="n">input_spot_table</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cell_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Array of segmented cell IDs for each spot in the table</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>        

<div class="viewcode-block" id="SegmentationResult.spot_table">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.SegmentationResult.spot_table">[docs]</a>
    <span class="k">def</span> <span class="nf">spot_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_spots</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new SpotTable with cell_ids determined by the segmentation.</span>

<span class="sd">        if min_spots is given, then it specifies the threshold below which cells will be discarded</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cell_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_ids</span>

        <span class="k">if</span> <span class="n">min_spots</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cell_ids</span> <span class="o">=</span> <span class="n">cell_ids</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">cids</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cell_ids</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">cid</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cids</span><span class="p">,</span> <span class="n">counts</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">min_spots</span><span class="p">:</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">cell_ids</span> <span class="o">==</span> <span class="n">cid</span>
                    <span class="n">cell_ids</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_spot_table</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">cell_ids</span><span class="o">=</span><span class="n">cell_ids</span><span class="p">)</span></div>


<div class="viewcode-block" id="SegmentationResult.save">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.SegmentationResult.save">[docs]</a>
    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">))</span></div>
</div>



<div class="viewcode-block" id="SegmentationMethod">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.SegmentationMethod">[docs]</a>
<span class="k">class</span> <span class="nc">SegmentationMethod</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class defining segmentation methods.</span>

<span class="sd">    Subclasses should initialize with a dictionary of options, then calling</span>
<span class="sd">    run(spot_table) will execute the segmentation method and return a SegmentationResult.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span><span class="nb">dict</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="n">options</span>
        
<div class="viewcode-block" id="SegmentationMethod.run">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.SegmentationMethod.run">[docs]</a>
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spot_table</span><span class="p">:</span><span class="n">SpotTable</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Run segmentation on spot_table and return a Segmentation object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

        
    <span class="k">def</span> <span class="nf">_get_spot_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spot_table</span><span class="p">:</span><span class="n">SpotTable</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the SpotTable instance to run segmentation on. </span>
<span class="sd">        </span>
<span class="sd">        If spot_table is a string, load from npz file.</span>
<span class="sd">        </span>
<span class="sd">        If a sub-region is specified in options, return the sub-table.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spot_table</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">spot_table</span> <span class="o">=</span> <span class="n">SpotTable</span><span class="o">.</span><span class="n">load_npz</span><span class="p">(</span><span class="n">spot_table</span><span class="p">)</span>
           
        <span class="n">region</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;region&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">region</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">spot_table</span> <span class="o">=</span> <span class="n">spot_table</span><span class="o">.</span><span class="n">get_subregion</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">spot_table</span></div>

        


<div class="viewcode-block" id="CellposeSegmentationMethod">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.CellposeSegmentationMethod">[docs]</a>
<span class="k">class</span> <span class="nc">CellposeSegmentationMethod</span><span class="p">(</span><span class="n">SegmentationMethod</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implements 2D or 3D cellpose segmentation on SpotTable</span>

<span class="sd">    Will automatically segment from images attached to the SpotTable or</span>
<span class="sd">    generate an image from total mRNA.</span>
<span class="sd">    </span>
<span class="sd">    options = {</span>
<span class="sd">        &#39;region&#39;: ((xmin, xmax), (ymin, ymax)),  # or None for whole table</span>
<span class="sd">        &#39;cellpose_model&#39;: &#39;cyto2&#39;,</span>
<span class="sd">        &#39;images&#39;: {</span>
<span class="sd">            &#39;nuclei&#39;: &#39;DAPI&#39;,</span>
<span class="sd">            &#39;cyto&#39;: &#39;total_mrna&#39;,</span>
<span class="sd">        },</span>
<span class="sd">        &#39;px_size&#39;: 0.108,          # um / px</span>
<span class="sd">        &#39;cell_dia&#39;: 10,            # um</span>
<span class="sd">        &#39;z_plane_thickness&#39;: 1.5,  # um</span>
<span class="sd">        &#39;cellpose_options&#39;: {</span>
<span class="sd">            &#39;gpu&#39;: True,</span>
<span class="sd">            &#39;batch_size&#39;: 8,</span>
<span class="sd">        },</span>
<span class="sd">        &#39;dilate&#39;: 0,  # um - dilate segmentation after cellpose has finished</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
        
<div class="viewcode-block" id="CellposeSegmentationMethod.run">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.CellposeSegmentationMethod.run">[docs]</a>
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spot_table</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">cellpose.models</span>
        <span class="n">spot_table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_spot_table</span><span class="p">(</span><span class="n">spot_table</span><span class="p">)</span>
        
        <span class="c1"># collect all cellpose options</span>
        <span class="n">cp_opts</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;z_axis&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s1">&#39;channel_axis&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
            <span class="s1">&#39;batch_size&#39;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span>   <span class="c1"># more if memory allows</span>
            <span class="s1">&#39;normalize&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="s1">&#39;tile&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="s1">&#39;diameter&#39;</span><span class="p">:</span> <span class="kc">None</span> <span class="c1"># if None, cellpose will estimate diameter or use from pretrained model file</span>
        <span class="p">}</span>
        <span class="n">cp_opts</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;cellpose_options&#39;</span><span class="p">])</span>
        <span class="n">cp_opts</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;anisotropy&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;z_plane_thickness&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;px_size&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;cell_dia&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">manual_diam</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;cell_dia&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;px_size&#39;</span><span class="p">]</span>
            <span class="n">cp_opts</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;diameter&#39;</span><span class="p">:</span> <span class="n">manual_diam</span><span class="p">})</span>
        
        <span class="c1"># collect images</span>
        <span class="n">images</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="s1">&#39;nuclei&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;images&#39;</span><span class="p">]:</span>
            <span class="n">img_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;images&#39;</span><span class="p">][</span><span class="s1">&#39;nuclei&#39;</span><span class="p">]</span>
            <span class="n">images</span><span class="p">[</span><span class="s1">&#39;nuclei&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_image_spec</span><span class="p">(</span><span class="n">img_spec</span><span class="p">,</span> <span class="n">spot_table</span><span class="p">,</span> <span class="n">px_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;px_size&#39;</span><span class="p">],</span> <span class="n">images</span><span class="o">=</span><span class="n">images</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;cyto&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;images&#39;</span><span class="p">]:</span>
            <span class="n">img_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;images&#39;</span><span class="p">][</span><span class="s1">&#39;cyto&#39;</span><span class="p">]</span>
            <span class="n">img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_image_spec</span><span class="p">(</span><span class="n">img_spec</span><span class="p">,</span> <span class="n">spot_table</span><span class="p">,</span> <span class="n">px_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;px_size&#39;</span><span class="p">],</span> <span class="n">images</span><span class="o">=</span><span class="n">images</span><span class="p">)</span>
            <span class="n">images</span><span class="p">[</span><span class="s1">&#39;cyto&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">img</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">images</span> <span class="o">=</span> <span class="n">images</span>

        <span class="c1"># prepare image data for segmentation</span>
        <span class="n">first_image</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">images</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cp_opts</span><span class="p">[</span><span class="s1">&#39;do_3D&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">first_image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">images</span><span class="p">[</span><span class="s1">&#39;cyto&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">images</span><span class="p">[</span><span class="s1">&#39;nuclei&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">cyto_data</span> <span class="o">=</span> <span class="n">images</span><span class="p">[</span><span class="s1">&#39;cyto&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
            <span class="n">image_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">images</span><span class="p">[</span><span class="s1">&#39;cyto&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cyto_data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">image_data</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cyto_data</span>
            <span class="n">image_data</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">images</span><span class="p">[</span><span class="s1">&#39;nuclei&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
            <span class="n">image_data</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">channels</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>  <span class="c1"># cyto=1 (red), nuclei=2 (green)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">image_data</span> <span class="o">=</span> <span class="n">first_image</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
            <span class="n">channels</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            
        <span class="c1"># decide whether to use GPU</span>
        <span class="n">gpu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cellpose_gpu&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gpu_msg</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">gpu</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="kn">import</span> <span class="nn">torch</span>
                <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">device_count</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">gpu</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">gpu_msg</span> <span class="o">=</span> <span class="s2">&quot;enabled GPU&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">gpu</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">gpu_msg</span> <span class="o">=</span> <span class="s2">&quot;no GPU found&quot;</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="n">gpu</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gpu_msg</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">traceback</span><span class="o">.</span><span class="n">format_exc</span><span class="p">())</span>

        <span class="c1"># initialize cellpose model</span>
        <span class="n">cp_opts</span><span class="p">[</span><span class="s1">&#39;channels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">channels</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;cellpose_model&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;cyto&#39;</span><span class="p">,</span> <span class="s1">&#39;cyto2&#39;</span><span class="p">,</span> <span class="s1">&#39;nuclei&#39;</span><span class="p">]:</span>
            <span class="c1"># use a default cellpose 1.0 model</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">cellpose</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">Cellpose</span><span class="p">(</span><span class="n">model_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;cellpose_model&#39;</span><span class="p">],</span> <span class="n">gpu</span><span class="o">=</span><span class="n">gpu</span><span class="p">)</span>
            <span class="c1"># run segmentation</span>
            <span class="n">masks</span><span class="p">,</span> <span class="n">flows</span><span class="p">,</span> <span class="n">styles</span><span class="p">,</span> <span class="n">diams</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">image_data</span><span class="p">,</span> <span class="o">**</span><span class="n">cp_opts</span><span class="p">)</span>
            <span class="n">cellpose_output</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;masks&#39;</span><span class="p">:</span> <span class="n">masks</span><span class="p">,</span> 
                <span class="s1">&#39;flows&#39;</span><span class="p">:</span> <span class="n">flows</span><span class="p">,</span> 
                <span class="s1">&#39;styles&#39;</span><span class="p">:</span> <span class="n">styles</span><span class="p">,</span> 
                <span class="s1">&#39;diams&#39;</span><span class="p">:</span> <span class="n">diams</span><span class="p">,</span>
            <span class="p">}</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># use a path to a custom model</span>
            <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;cellpose_model&#39;</span><span class="p">])</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">cellpose</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">CellposeModel</span><span class="p">(</span><span class="n">pretrained_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;cellpose_model&#39;</span><span class="p">],</span> <span class="n">gpu</span><span class="o">=</span><span class="n">gpu</span><span class="p">)</span>
            <span class="c1"># run segmentation</span>
            <span class="n">masks</span><span class="p">,</span> <span class="n">flows</span><span class="p">,</span> <span class="n">styles</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">image_data</span><span class="p">,</span> <span class="o">**</span><span class="n">cp_opts</span><span class="p">)</span>
            <span class="n">cellpose_output</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;masks&#39;</span><span class="p">:</span> <span class="n">masks</span><span class="p">,</span> 
                <span class="s1">&#39;flows&#39;</span><span class="p">:</span> <span class="n">flows</span><span class="p">,</span> 
                <span class="s1">&#39;styles&#39;</span><span class="p">:</span> <span class="n">styles</span><span class="p">,</span> 
            <span class="p">}</span>

        <span class="n">dilate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;dilate&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dilate</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">masks</span> <span class="o">=</span> <span class="n">dilate_labels</span><span class="p">(</span><span class="n">masks</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="n">dilate</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;px_size&#39;</span><span class="p">])</span>
            <span class="n">cellpose_output</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;masks&#39;</span><span class="p">:</span> <span class="n">masks</span><span class="p">})</span>

        <span class="c1"># return result object</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">CellposeSegmentationResult</span><span class="p">(</span>
            <span class="n">method</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> 
            <span class="n">input_spot_table</span><span class="o">=</span><span class="n">spot_table</span><span class="p">,</span>
            <span class="n">cellpose_output</span><span class="o">=</span><span class="n">cellpose_output</span><span class="p">,</span>
            <span class="n">image_transform</span><span class="o">=</span><span class="n">first_image</span><span class="o">.</span><span class="n">transform</span><span class="p">,</span>
        <span class="p">)</span>
            
        <span class="k">return</span> <span class="n">result</span></div>


    <span class="k">def</span> <span class="nf">_read_image_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img_spec</span><span class="p">,</span> <span class="n">spot_table</span><span class="p">,</span> <span class="n">px_size</span><span class="p">,</span> <span class="n">images</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return an Image to be used in segmentation based on img_spec:</span>
<span class="sd">        </span>
<span class="sd">        - An Image instance is returned as-is</span>
<span class="sd">        - &quot;total_mrna&quot; returns an image generated from spot density</span>
<span class="sd">        - Any other string returns an image channel attached to the spot table</span>
<span class="sd">        - {&#39;channel&#39;: channel, &#39;frame&#39;: int} can be used to select a single frame</span>
<span class="sd">        - {&#39;channel&#39;: &#39;total_mrna&#39;, &#39;n_planes&#39;: int, &#39;frame&#39;: int, &#39;gauss_kernel&#39;: (1, 3, 3), &#39;median_kernel&#39;: (2, 10, 10)} can be ued to configure total mrna image generation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># optionally, cyto image may be generated from spot table total mrna        </span>
        <span class="k">if</span> <span class="n">img_spec</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img_spec</span><span class="p">,</span> <span class="n">ImageBase</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">img_spec</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img_spec</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">img_spec</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;channel&#39;</span><span class="p">:</span> <span class="n">img_spec</span><span class="p">}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img_spec</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Bad image spec: </span><span class="si">{</span><span class="n">img_spec</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">img_spec</span><span class="p">[</span><span class="s1">&#39;channel&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;total_mrna&#39;</span><span class="p">:</span>
            <span class="n">opts</span> <span class="o">=</span> <span class="n">img_spec</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">opts</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;channel&#39;</span><span class="p">)</span>
            <span class="n">opts</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_suggest_image_spec</span><span class="p">(</span><span class="n">spot_table</span><span class="p">,</span> <span class="n">px_size</span><span class="p">,</span> <span class="n">images</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_total_mrna_image</span><span class="p">(</span><span class="n">spot_table</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">spot_table</span><span class="o">.</span><span class="n">get_image</span><span class="p">(</span><span class="n">channel</span><span class="o">=</span><span class="n">img_spec</span><span class="p">[</span><span class="s1">&#39;channel&#39;</span><span class="p">],</span> <span class="n">frame</span><span class="o">=</span><span class="n">img_spec</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;frame&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_suggest_image_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spot_table</span><span class="p">,</span> <span class="n">px_size</span><span class="p">,</span> <span class="n">images</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Given a pixel size, return {&#39;image_shape&#39;: shape, &#39;image_transform&#39;: tr} covering the entire area of spot_table.</span>
<span class="sd">        If any images are already present, use those as templates instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">img</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">images</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;image_shape&#39;</span><span class="p">:</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="s1">&#39;image_transform&#39;</span><span class="p">:</span> <span class="n">img</span><span class="o">.</span><span class="n">transform</span><span class="p">}</span>

        <span class="n">bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">spot_table</span><span class="o">.</span><span class="n">bounds</span><span class="p">())</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">px_size</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">bounds</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bounds</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">scale</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        
        <span class="n">tr_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">tr_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tr_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span>
        <span class="n">tr_matrix</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">scale</span> <span class="o">*</span> <span class="n">bounds</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">image_tr</span> <span class="o">=</span> <span class="n">ImageTransform</span><span class="p">(</span><span class="n">tr_matrix</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;image_shape&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="s1">&#39;image_transform&#39;</span><span class="p">:</span> <span class="n">image_tr</span><span class="p">}</span>

<div class="viewcode-block" id="CellposeSegmentationMethod.get_total_mrna_image">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.CellposeSegmentationMethod.get_total_mrna_image">[docs]</a>
    <span class="k">def</span> <span class="nf">get_total_mrna_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spot_table</span><span class="p">,</span> <span class="n">image_shape</span><span class="p">:</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">image_transform</span><span class="p">:</span><span class="n">ImageTransform</span><span class="p">,</span> <span class="n">n_planes</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">frame</span><span class="p">:</span><span class="nb">int</span><span class="o">|</span><span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gauss_kernel</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">median_kernel</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)):</span>

        <span class="n">image_shape_full</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_planes</span><span class="p">,</span> <span class="o">*</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">density_img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">image_shape_full</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>

        <span class="n">spot_px</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_spots_to_img_px</span><span class="p">(</span><span class="n">spot_table</span><span class="p">,</span> <span class="n">image_transform</span><span class="o">=</span><span class="n">image_transform</span><span class="p">,</span> <span class="n">image_shape</span><span class="o">=</span><span class="n">image_shape_full</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_planes</span><span class="p">):</span>
            <span class="n">z_mask</span> <span class="o">=</span> <span class="n">spot_px</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">spot_px</span><span class="p">[</span><span class="n">z_mask</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">spot_px</span><span class="p">[</span><span class="n">z_mask</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="p">[</span>
                <span class="c1"># is this correct? test on rectangular tile</span>
                <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span>
            <span class="p">]</span>
            <span class="n">density_img</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram2d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="kn">import</span> <span class="nn">scipy.ndimage</span>
        <span class="c1"># very sensitive to these parameters :/</span>
        <span class="n">density_img</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">(</span><span class="n">density_img</span><span class="p">,</span> <span class="n">gauss_kernel</span><span class="p">)</span>
        <span class="n">density_img</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">median_filter</span><span class="p">(</span><span class="n">density_img</span><span class="p">,</span> <span class="n">median_kernel</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">frame</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Image</span><span class="p">(</span><span class="n">density_img</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">transform</span><span class="o">=</span><span class="n">image_transform</span><span class="p">,</span> <span class="n">channels</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Total mRNA&#39;</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">get_frame</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Image</span><span class="p">(</span><span class="n">density_img</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">transform</span><span class="o">=</span><span class="n">image_transform</span><span class="p">,</span> <span class="n">channels</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Total mRNA&#39;</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></div>


<div class="viewcode-block" id="CellposeSegmentationMethod.map_spots_to_img_px">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.CellposeSegmentationMethod.map_spots_to_img_px">[docs]</a>
    <span class="k">def</span> <span class="nf">map_spots_to_img_px</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spot_table</span><span class="p">:</span><span class="n">SpotTable</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span><span class="n">Image</span><span class="o">|</span><span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">image_transform</span><span class="p">:</span><span class="n">ImageTransform</span><span class="o">|</span><span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">image_shape</span><span class="p">:</span><span class="nb">tuple</span><span class="o">|</span><span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Map spot table (x, y, z) positions to image (frame, row, col). </span>

<span class="sd">        Optionally, provide the *image_transform* and *image_shape* instead of *image*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">image</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">image_transform</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">image_shape</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="n">image_shape</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">image_transform</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">transform</span>

        <span class="n">spot_xy</span> <span class="o">=</span> <span class="n">spot_table</span><span class="o">.</span><span class="n">pos</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">spot_px_rc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">image_transform</span><span class="o">.</span><span class="n">map_to_pixels</span><span class="p">(</span><span class="n">spot_xy</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># for this dataset, z values are already integer index instead of um</span>
        <span class="k">if</span> <span class="n">spot_table</span><span class="o">.</span><span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">spot_px_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spot_table</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">spot_px_z</span> <span class="o">=</span> <span class="n">spot_table</span><span class="o">.</span><span class="n">z</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># some spots may be a little past the edge of the image; </span>
        <span class="c1"># just clip these as they&#39;ll be discarded when tiles are merged anyway</span>
        <span class="n">spot_px_rc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">spot_px_rc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">image_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">spot_px_rc</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">spot_px_rc</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">image_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">spot_px_z</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">spot_px_rc</span><span class="p">])</span></div>
</div>



<div class="viewcode-block" id="CellposeSegmentationResult">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.CellposeSegmentationResult">[docs]</a>
<span class="k">class</span> <span class="nc">CellposeSegmentationResult</span><span class="p">(</span><span class="n">SegmentationResult</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span><span class="n">SegmentationMethod</span><span class="p">,</span> <span class="n">input_spot_table</span><span class="p">:</span><span class="n">SpotTable</span><span class="p">,</span> <span class="n">cellpose_output</span><span class="p">:</span><span class="nb">dict</span><span class="p">,</span> <span class="n">image_transform</span><span class="p">:</span><span class="n">ImageTransform</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">input_spot_table</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cellpose_output</span> <span class="o">=</span> <span class="n">cellpose_output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image_transform</span> <span class="o">=</span> <span class="n">image_transform</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cell_ids</span> <span class="o">=</span> <span class="kc">None</span>
        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cell_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Array of segmented cell IDs for each spot in the table</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># use segmented masks to assign each spot to a cell</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cell_ids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">spot_table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_spot_table</span>
            <span class="n">mask_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_image</span>
            <span class="n">spot_px</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="o">.</span><span class="n">map_spots_to_img_px</span><span class="p">(</span><span class="n">spot_table</span><span class="p">,</span> <span class="n">mask_img</span><span class="p">)</span>

            <span class="c1"># assign segmented cell IDs to a new table</span>
            <span class="n">masks</span> <span class="o">=</span> <span class="n">mask_img</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellpose_output</span><span class="p">[</span><span class="s1">&#39;masks&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># 2D mask</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cell_ids</span> <span class="o">=</span> <span class="n">masks</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">spot_px</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">spot_px</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># 3D mask</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cell_ids</span> <span class="o">=</span> <span class="n">masks</span><span class="p">[</span><span class="n">spot_px</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">spot_px</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">spot_px</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]]</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cell_ids</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mask_image</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return Image instance containing mask data and pixel transform</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="c1"># annotate segmentation mask with spot-to-pixel transform</span>
        <span class="n">masks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellpose_output</span><span class="p">[</span><span class="s1">&#39;masks&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">masks</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># add frame and channel axes back</span>
            <span class="n">masks</span> <span class="o">=</span> <span class="n">masks</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># add channel axis back</span>
            <span class="n">masks</span> <span class="o">=</span> <span class="n">masks</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">Image</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">masks</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">image_transform</span><span class="p">,</span> <span class="n">channels</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Cellpose Mask&#39;</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        
<div class="viewcode-block" id="CellposeSegmentationResult.show">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.CellposeSegmentationResult.show">[docs]</a>
    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Display segmentation result in matplotlib axes</span>
<span class="sd">        &quot;&quot;&quot;</span></div>
</div>

        

<div class="viewcode-block" id="BaysorSegmentationMethod">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.BaysorSegmentationMethod">[docs]</a>
<span class="k">class</span> <span class="nc">BaysorSegmentationMethod</span><span class="p">(</span><span class="n">SegmentationMethod</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implements 3D Baysor segmentation on SpotTable</span>

<span class="sd">    Requires a Baysor binary to be executable on the system.</span>

<span class="sd">    options = {</span>
<span class="sd">        &#39;region&#39;: ((xmin, xmax), (ymin, ymax)),  # or None for whole table</span>
<span class="sd">        &#39;baysor_bin&#39;: &#39;/path/to/Baysor&#39;,</span>
<span class="sd">        &#39;baysor_output_path&#39;: &#39;/path/to/baysor/data&#39;,</span>
<span class="sd">        &#39;use_prior_segmentation&#39;: True,</span>
<span class="sd">        &#39;no_gene_names&#39;: False,          # if true, remove gene names</span>
<span class="sd">        &#39;cell_dia&#39;: 10,                  # um</span>
<span class="sd">        &#39;z_plane_thickness&#39;: 1.5,        # um</span>
<span class="sd">        &#39;baysor_options&#39;: {</span>
<span class="sd">            &#39;scale-std&#39;: &#39;25%&#39;,</span>
<span class="sd">            &#39;prior-segmentation-confidence&#39;: None,</span>
<span class="sd">            &#39;n-clusters&#39;: None,</span>
<span class="sd">            &#39;no-ncv-estimation&#39;: True,</span>
<span class="sd">        }</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>

<div class="viewcode-block" id="BaysorSegmentationMethod.run">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.BaysorSegmentationMethod.run">[docs]</a>
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spot_table</span><span class="p">):</span>
        <span class="n">spot_table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_spot_table</span><span class="p">(</span><span class="n">spot_table</span><span class="p">)</span>

        <span class="c1"># collect all cellpose options</span>
        <span class="n">baysor_opts</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;scale&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;cell_dia&#39;</span><span class="p">],</span>
            <span class="s1">&#39;scale-std&#39;</span><span class="p">:</span> <span class="s1">&#39;25%&#39;</span><span class="p">,</span>
            <span class="s1">&#39;prior-segmentation-confidence&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;n-clusters&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;no-ncv-estimation&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">baysor_opts</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;baysor_options&#39;</span><span class="p">])</span>

        <span class="c1"># correct Z positions from layers to micrometers</span>
        <span class="c1"># Note: ideally we shouldn&#39;t need to do this -- the merscope data should just have correct z coordinates to begin with.</span>
        <span class="n">baysor_spot_table</span> <span class="o">=</span> <span class="n">spot_table</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">baysor_spot_table</span><span class="o">.</span><span class="n">pos</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;z_plane_thickness&#39;</span><span class="p">]</span>

        <span class="c1"># remove gene IDs--only use spot position to perform segmentation</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;no_gene_names&#39;</span><span class="p">]:</span>
            <span class="n">baysor_spot_table</span><span class="o">.</span><span class="n">gene_ids</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># using --num-cells should increase convergence speed</span>
        <span class="k">if</span> <span class="n">spot_table</span><span class="o">.</span><span class="n">cell_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_cells</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">spot_table</span><span class="o">.</span><span class="n">cell_ids</span><span class="p">))</span>
            <span class="n">baysor_opts</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;num-cells-init&#39;</span><span class="p">,</span> <span class="n">num_cells</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_cells</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">save_columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="s1">&#39;gene_id&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;use_prior_segmentation&#39;</span><span class="p">]:</span>
            <span class="n">save_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;cell_id&#39;</span><span class="p">)</span>

        <span class="c1"># we communicate with baysor by writing files to disk, so pick a place to do that</span>
        <span class="n">output_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;baysor_output_path&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">out_is_tmp</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">output_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_path</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkdtemp</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;baysor_run_&#39;</span><span class="p">)</span>
            <span class="n">out_is_tmp</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">inp_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_path</span><span class="p">,</span> <span class="s1">&#39;input_spot_table.csv&#39;</span><span class="p">)</span>
        <span class="n">out_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_path</span><span class="p">,</span> <span class="s1">&#39;output_spot_table.csv&#39;</span><span class="p">)</span>

        <span class="c1"># save csv to tmp</span>
        <span class="n">baysor_spot_table</span><span class="o">.</span><span class="n">save_csv</span><span class="p">(</span><span class="n">inp_file</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">save_columns</span><span class="p">)</span>

        <span class="n">cmd</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;baysor_bin&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> run -o </span><span class="si">{</span><span class="n">out_file</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">for</span> <span class="n">arg</span><span class="p">,</span><span class="n">val</span> <span class="ow">in</span> <span class="n">baysor_opts</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">cmd</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; --</span><span class="si">{</span><span class="n">arg</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cmd</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; --</span><span class="si">{</span><span class="n">arg</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">cmd</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; -x x -y y -z z -g gene_id </span><span class="si">{</span><span class="n">inp_file</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;use_prior_segmentation&#39;</span><span class="p">]:</span>
            <span class="n">cmd</span> <span class="o">+=</span> <span class="s2">&quot; :cell_id&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">baysor_command</span> <span class="o">=</span> <span class="n">cmd</span>

        <span class="c1"># run baysor</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span>

        <span class="c1"># return result object</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">BaysorSegmentationResult</span><span class="p">(</span>
            <span class="n">method</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">input_spot_table</span><span class="o">=</span><span class="n">spot_table</span><span class="p">,</span>
            <span class="n">baysor_command</span><span class="o">=</span><span class="n">cmd</span><span class="p">,</span>
            <span class="n">baysor_output</span><span class="o">=</span><span class="n">out_file</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span></div>
</div>



<div class="viewcode-block" id="load_baysor_result">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.load_baysor_result">[docs]</a>
<span class="k">def</span> <span class="nf">load_baysor_result</span><span class="p">(</span><span class="n">result_file</span><span class="p">,</span> <span class="n">remove_noise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">remove_no_cell</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">brl_output</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">brl_output</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">),(</span><span class="s1">&#39;gene&#39;</span><span class="p">,</span><span class="nb">str</span><span class="p">),(</span><span class="s1">&#39;cluster&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;cell&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;is_noise&#39;</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)]</span>

        <span class="n">converters</span> <span class="o">=</span> <span class="p">{</span>
            <span class="mi">6</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">==</span> <span class="s1">&#39;true&#39;</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">result_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span>
            <span class="n">result_file</span><span class="p">,</span>
            <span class="n">skiprows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">usecols</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
            <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">converters</span><span class="o">=</span><span class="n">converters</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">),(</span><span class="s1">&#39;cluster&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;cell&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;is_noise&#39;</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)]</span>

        <span class="n">converters</span> <span class="o">=</span> <span class="p">{</span>
            <span class="mi">9</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">==</span> <span class="s1">&#39;true&#39;</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">result_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span>
            <span class="n">result_file</span><span class="p">,</span>
            <span class="n">skiprows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">usecols</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span>
            <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">converters</span><span class="o">=</span><span class="n">converters</span>
        <span class="p">)</span>

    <span class="n">z_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">result_data</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">remove_noise</span><span class="p">:</span>
        <span class="n">result_data</span> <span class="o">=</span> <span class="n">result_data</span><span class="p">[</span><span class="o">~</span><span class="n">result_data</span><span class="p">[</span><span class="s1">&#39;is_noise&#39;</span><span class="p">]]</span>
    <span class="k">if</span> <span class="n">remove_no_cell</span><span class="p">:</span>
        <span class="n">result_data</span> <span class="o">=</span> <span class="n">result_data</span><span class="p">[</span><span class="n">result_data</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">result_data</span></div>



<div class="viewcode-block" id="BaysorSegmentationResult">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.BaysorSegmentationResult">[docs]</a>
<span class="k">class</span> <span class="nc">BaysorSegmentationResult</span><span class="p">(</span><span class="n">SegmentationResult</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span><span class="n">SegmentationMethod</span><span class="p">,</span> <span class="n">input_spot_table</span><span class="p">:</span><span class="n">SpotTable</span><span class="p">,</span> <span class="n">baysor_command</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">baysor_output</span><span class="p">:</span><span class="nb">str</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">input_spot_table</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">baysor_command</span> <span class="o">=</span> <span class="n">baysor_command</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">baysor_output</span> <span class="o">=</span> <span class="n">baysor_output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cell_ids</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cell_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Array of segmented cell IDs for each spot in the table</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># use segmented masks to assign each spot to a cell</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cell_ids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">spot_table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_spot_table</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">load_baysor_result</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">baysor_output</span><span class="p">,</span> <span class="n">remove_noise</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">remove_no_cell</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cell_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cell_ids</span></div>




<div class="viewcode-block" id="dilate_labels">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.dilate_labels">[docs]</a>
<span class="k">def</span> <span class="nf">dilate_labels</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">radius</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Dilate labeled regions of an image.</span>

<span class="sd">    Given an image with 0 in the background and objects labeled with different integer values (such</span>
<span class="sd">    as a cell segmentation mask), return a new image with objects expanded by *radius*.</span>

<span class="sd">    (Credit: https://stackoverflow.com/a/70261747)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">img</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="c1"># fill in all pixels with nearest non-zero value</span>
    <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
    <span class="n">interpolator</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">NearestNDInterpolator</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">inds</span><span class="p">),</span> <span class="n">img</span><span class="p">[</span><span class="n">inds</span><span class="p">])</span>
    <span class="n">interpolated</span> <span class="o">=</span> <span class="n">interpolator</span><span class="p">(</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="c1"># make a dilated mask to return background pixels to 0</span>
    <span class="n">ri</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">radius</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">circle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfunction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">:</span> <span class="p">(((</span><span class="n">i</span><span class="o">-</span><span class="n">ri</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="n">ri</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">radius</span><span class="p">,</span> <span class="p">(</span><span class="n">ri</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">ri</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">circle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfunction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">:</span> <span class="p">(((</span><span class="n">i</span><span class="o">-</span><span class="n">ri</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="n">ri</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="n">ri</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">radius</span><span class="p">,</span> <span class="p">(</span><span class="n">ri</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">ri</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">ri</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Not implemented for </span><span class="si">{</span><span class="n">img</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2">D images&quot;</span><span class="p">)</span>
    <span class="n">dilated_mask</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">grey_dilation</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">footprint</span><span class="o">=</span><span class="n">circle</span><span class="p">)</span>
    <span class="n">interpolated</span><span class="p">[</span><span class="o">~</span><span class="n">dilated_mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">return</span> <span class="n">interpolated</span></div>



<div class="viewcode-block" id="merge_segmentation_results">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.merge_segmentation_results">[docs]</a>
<span class="k">def</span> <span class="nf">merge_segmentation_results</span><span class="p">(</span><span class="n">spot_table</span><span class="p">:</span> <span class="n">SpotTable</span><span class="p">,</span> <span class="n">run_spec</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">tiles</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">SpotTable</span><span class="p">]</span><span class="o">|</span><span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Merge results of a tiled segmentation, updating spot_table.cell_ids in place.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    spot_table: SpotTable</span>
<span class="sd">        The entire spot table to which to assign cell_ids.</span>
<span class="sd">    run_spec: dict</span>
<span class="sd">        The specifications provided to segment each tile on the hpc.</span>
<span class="sd">    tiles: list[SpotTable]|None</span>
<span class="sd">        The individual tiles that were segmented.</span>
<span class="sd">        If not provided, will be generated from spot_table and run_spec.</span>

<span class="sd">    Returns</span>
<span class="sd">    ------- </span>
<span class="sd">    cell_ids</span>
<span class="sd">        The cell_ids assigned to each spot in spot_table.</span>
<span class="sd">    merge_results</span>
<span class="sd">        Information about conflicts collected during tile merging.</span>
<span class="sd">    skipped</span>
<span class="sd">        Indices of tiles skipped during segmentation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">spot_table</span><span class="o">.</span><span class="n">cell_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spot_table</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">spot_table</span><span class="o">.</span><span class="n">cell_ids</span><span class="p">[:]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="n">merge_results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">skipped</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tile_spec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tqdm</span><span class="p">(</span><span class="n">run_spec</span><span class="o">.</span><span class="n">values</span><span class="p">())):</span>
        <span class="n">cell_id_file</span> <span class="o">=</span> <span class="n">tile_spec</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s1">&#39;cell_id_file&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">cell_id_file</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping tile </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> : no cell ID file generated&quot;</span><span class="p">)</span>
            <span class="n">skipped</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">tiles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Use tiles in memory</span>
            <span class="n">tile</span> <span class="o">=</span> <span class="n">tiles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Recreate each tile from spot_table and run_spec</span>
            <span class="n">tile_rgn</span> <span class="o">=</span> <span class="n">tile_spec</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s1">&#39;subregion&#39;</span><span class="p">]</span>
            <span class="n">tile</span> <span class="o">=</span> <span class="n">spot_table</span><span class="o">.</span><span class="n">get_subregion</span><span class="p">(</span><span class="n">xlim</span> <span class="o">=</span> <span class="n">tile_rgn</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ylim</span> <span class="o">=</span> <span class="n">tile_rgn</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">tile</span><span class="o">.</span><span class="n">cell_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">cell_id_file</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">spot_table</span><span class="o">.</span><span class="n">merge_cells</span><span class="p">(</span><span class="n">tile</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
        <span class="n">merge_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="n">cell_ids</span> <span class="o">=</span> <span class="n">spot_table</span><span class="o">.</span><span class="n">cell_ids</span>

    <span class="k">return</span> <span class="n">cell_ids</span><span class="p">,</span> <span class="n">merge_results</span><span class="p">,</span> <span class="n">skipped</span></div>



<div class="viewcode-block" id="SegmentationRun">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.SegmentationRun">[docs]</a>
<span class="k">class</span> <span class="nc">SegmentationRun</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for running segmentation on a whole section (or subregion).</span>
<span class="sd">    When the class is initialized, it creates the segmentation output directory</span>
<span class="sd">    and sets paths for intermediate files.</span>

<span class="sd">    Each step has defined input and output files. Steps can be run individually</span>
<span class="sd">    by calling their respective methods or in a defined sequence by calling the</span>
<span class="sd">    run() method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dt_file: str or Path</span>
<span class="sd">        Path to the detected transcripts file.</span>
<span class="sd"> </span>
<span class="sd">    image_path: str or Path</span>
<span class="sd">        Path to the images.</span>

<span class="sd">    output_dir: str or Path</span>
<span class="sd">        Where to save output files.</span>

<span class="sd">    dt_cache: str or Path, optional</span>
<span class="sd">        Path to the detected transcripts cache file. Used for faster loading.</span>

<span class="sd">    subrgn: str or tuple</span>
<span class="sd">        The subregion to segment. Set to a string, e.g. &#39;DAPI&#39;, to segment the </span>
<span class="sd">        full region bounded by an associated image channel. To segment a </span>
<span class="sd">        smaller region, set to a tuple corresponding to a bounding box.</span>

<span class="sd">    seg_method: SegmentationMethod</span>
<span class="sd">        The segmentation method to use. Must be found in sis.segmentation.</span>

<span class="sd">    seg_opts: dict</span>
<span class="sd">        Options to pass to seg_method.</span>

<span class="sd">    polygon_opts: dict, optional</span>
<span class="sd">        Options to pass to for cell polygon generation. Currently supports save_file_extension and alpha_inv_coeff.</span>
<span class="sd">        Default is None, which sets save_file_extension to &#39;geojson&#39; and alpha_inv_coeff to 4/3.</span>
<span class="sd">        </span>
<span class="sd">    seg_hpc_opts: dict, None, optional</span>
<span class="sd">        Options to use for segmenting tiles on the hpc. Default is None</span>
<span class="sd">        </span>
<span class="sd">    polygon_hpc_opts: dict, None, optional</span>
<span class="sd">        Options to use for calculating cell polygons on the hpc. Default is None</span>

<span class="sd">    hpc_opts: dict, None, optional</span>
<span class="sd">        Options to use for both segmenting tiles and calculating cell polygons on the hpc (can be used in place of submitting both seg_hpc_opts and polygon_hpc_opts).</span>
<span class="sd">        Default is None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> 
            <span class="n">dt_file</span><span class="p">:</span> <span class="n">Path</span><span class="o">|</span><span class="nb">str</span><span class="p">,</span>
            <span class="n">image_path</span><span class="p">:</span> <span class="n">Path</span><span class="o">|</span><span class="nb">str</span><span class="p">,</span>
            <span class="n">output_dir</span><span class="p">:</span> <span class="n">Path</span><span class="o">|</span><span class="nb">str</span><span class="p">,</span>
            <span class="n">dt_cache</span><span class="p">:</span> <span class="n">Path</span><span class="o">|</span><span class="nb">str</span><span class="o">|</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">subrgn</span><span class="p">:</span> <span class="nb">str</span><span class="o">|</span><span class="nb">tuple</span><span class="p">,</span>
            <span class="n">seg_method</span><span class="p">:</span> <span class="n">SegmentationMethod</span><span class="p">,</span>
            <span class="n">seg_opts</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
            <span class="n">polygon_opts</span><span class="p">:</span> <span class="nb">dict</span><span class="o">|</span><span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">seg_hpc_opts</span><span class="p">:</span> <span class="nb">dict</span><span class="o">|</span><span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">polygon_hpc_opts</span><span class="p">:</span> <span class="nb">dict</span><span class="o">|</span><span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">hpc_opts</span><span class="p">:</span> <span class="nb">dict</span><span class="o">|</span><span class="kc">None</span><span class="o">=</span><span class="kc">None</span>
            <span class="p">):</span>

        <span class="c1"># input/output paths</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image_path</span> <span class="o">=</span> <span class="n">image_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">detected_transcripts_file</span> <span class="o">=</span> <span class="n">dt_file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">detected_transcripts_cache</span> <span class="o">=</span> <span class="n">dt_cache</span> 

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="n">PurePath</span><span class="p">):</span>
            <span class="n">output_dir</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span> <span class="o">=</span> <span class="n">output_dir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># intermediate file paths</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_intermediate_file_paths</span><span class="p">()</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">seg_hpc_opts</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">hpc_opts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;One of either seg_hpc_opts or hpc_opts must be provided.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">polygon_hpc_opts</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">hpc_opts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;One of either polygon_hpc_opts or hpc_opts must be provided.&quot;</span><span class="p">)</span>

        <span class="c1"># segmentation parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subrgn</span> <span class="o">=</span> <span class="n">subrgn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seg_method</span> <span class="o">=</span> <span class="n">seg_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seg_opts</span> <span class="o">=</span> <span class="n">seg_opts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seg_opts</span><span class="p">[</span><span class="s1">&#39;options&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;cellpose_options&#39;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;min_size&#39;</span><span class="p">,</span> <span class="mi">5000</span><span class="p">)</span> <span class="c1"># Set min_size to 5000 if it wasn&#39;t set</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seg_hpc_opts</span> <span class="o">=</span> <span class="n">hpc_opts</span> <span class="k">if</span> <span class="n">seg_hpc_opts</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">seg_hpc_opts</span>

        <span class="c1"># polygon parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polygon_opts</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">polygon_opts</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">polygon_opts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polygon_opts</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;save_file_extension&#39;</span><span class="p">,</span> <span class="s1">&#39;geojson&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polygon_opts</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;alpha_inv_coeff&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polygon_hpc_opts</span> <span class="o">=</span> <span class="n">hpc_opts</span> <span class="k">if</span> <span class="n">polygon_hpc_opts</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">polygon_hpc_opts</span>

        <span class="c1"># metadata dict of initial parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_path</span> <span class="o">=</span> <span class="n">output_dir</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="s1">&#39;seg_meta.json&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_metadata</span><span class="p">()</span>


<div class="viewcode-block" id="SegmentationRun.get_load_func">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.SegmentationRun.get_load_func">[docs]</a>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">get_load_func</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span></div>


<div class="viewcode-block" id="SegmentationRun.get_load_args">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.SegmentationRun.get_load_args">[docs]</a>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">get_load_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span></div>


<div class="viewcode-block" id="SegmentationRun.set_intermediate_file_paths">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.SegmentationRun.set_intermediate_file_paths">[docs]</a>
    <span class="k">def</span> <span class="nf">set_intermediate_file_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">output_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regions_path</span> <span class="o">=</span> <span class="n">output_dir</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="s1">&#39;regions.json&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seg_run_spec_path</span> <span class="o">=</span> <span class="n">output_dir</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="s1">&#39;seg_run_spec.pkl&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polygon_run_spec_path</span> <span class="o">=</span> <span class="n">output_dir</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="s1">&#39;polygon_run_spec.pkl&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tile_save_path</span> <span class="o">=</span> <span class="n">output_dir</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="s1">&#39;seg_tiles/&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cid_path</span> <span class="o">=</span> <span class="n">output_dir</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="s1">&#39;segmentation.npy&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cbg_path</span> <span class="o">=</span> <span class="n">output_dir</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="s1">&#39;cell_by_gene.h5ad&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polygon_save_path</span> <span class="o">=</span> <span class="n">output_dir</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="s1">&#39;cell_polygons/&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="SegmentationRun.update_metadata">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.SegmentationRun.update_metadata">[docs]</a>
    <span class="k">def</span> <span class="nf">update_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;dt_file&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">detected_transcripts_file</span><span class="p">,</span>
                <span class="s1">&#39;image_path&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_path</span><span class="p">,</span>
                <span class="s1">&#39;output_dir&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="p">,</span>
                <span class="s1">&#39;dt_cache&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">detected_transcripts_cache</span><span class="p">,</span>
                <span class="s1">&#39;subrgn&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">subrgn</span><span class="p">,</span>
                <span class="s1">&#39;seg_method&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">seg_method</span><span class="p">,</span>
                <span class="s1">&#39;seg_opts&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">seg_opts</span><span class="p">,</span>
                <span class="s1">&#39;polygon_opts&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon_opts</span><span class="p">,</span>
                <span class="s1">&#39;seg_hpc_opts&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">seg_hpc_opts</span><span class="p">,</span>
                <span class="s1">&#39;polygon_hpc_opts&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon_hpc_opts</span><span class="p">,</span>
            <span class="p">}</span></div>


<div class="viewcode-block" id="SegmentationRun.save_metadata">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.SegmentationRun.save_metadata">[docs]</a>
    <span class="k">def</span> <span class="nf">save_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">overwrite</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">FileExistsError</span><span class="p">(</span><span class="s1">&#39;Metadata already saved and overwriting is not enabled.&#39;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">metadata_cl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">PurePath</span><span class="p">):</span>
                    <span class="n">metadata_cl</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">as_posix</span><span class="p">()</span>
                <span class="k">elif</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isclass</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                    <span class="n">metadata_cl</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="n">v</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">str</span><span class="o">|</span><span class="nb">tuple</span><span class="p">):</span>
                    <span class="n">metadata_cl</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_path</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">metadata_cl</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span></div>


<div class="viewcode-block" id="SegmentationRun.load_metadata">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.SegmentationRun.load_metadata">[docs]</a>
    <span class="k">def</span> <span class="nf">load_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_path</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">meta</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
 
        <span class="k">return</span> <span class="n">meta</span></div>


<div class="viewcode-block" id="SegmentationRun.save_regions">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.SegmentationRun.save_regions">[docs]</a>
    <span class="k">def</span> <span class="nf">save_regions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">regions</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">regions_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">regions</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;xlim&#39;</span><span class="p">,</span> <span class="s1">&#39;ylim&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">overwrite</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">regions_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">FileExistsError</span><span class="p">(</span><span class="s1">&#39;Regions are already saved and overwriting is not enabled.&#39;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">regions_df</span><span class="o">.</span><span class="n">to_json</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">regions_path</span><span class="p">)</span></div>


<div class="viewcode-block" id="SegmentationRun.load_regions">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.SegmentationRun.load_regions">[docs]</a>
    <span class="k">def</span> <span class="nf">load_regions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">regions_path</span><span class="o">.</span><span class="n">exists</span><span class="p">()</span>
        <span class="n">regions</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_json</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">regions_path</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">regions</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">regions</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">regions</span></div>


<div class="viewcode-block" id="SegmentationRun.save_run_spec">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.SegmentationRun.save_run_spec">[docs]</a>
    <span class="k">def</span> <span class="nf">save_run_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_spec</span><span class="p">,</span> <span class="n">run_spec_path</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">overwrite</span> <span class="ow">and</span> <span class="n">run_spec_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">FileExistsError</span><span class="p">(</span><span class="s1">&#39;Run spec already saved and overwriting is not enabled.&#39;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">run_spec_path</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">run_spec</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span></div>


<div class="viewcode-block" id="SegmentationRun.load_run_spec">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.SegmentationRun.load_run_spec">[docs]</a>
    <span class="k">def</span> <span class="nf">load_run_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_spec_path</span><span class="p">):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">run_spec_path</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">run_spec</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">run_spec</span></div>


<div class="viewcode-block" id="SegmentationRun.save_cell_ids">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.SegmentationRun.save_cell_ids">[docs]</a>
    <span class="k">def</span> <span class="nf">save_cell_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell_ids</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">overwrite</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">cid_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">FileExistsError</span><span class="p">(</span><span class="s1">&#39;Cell ids already saved and overwriting is not enabled.&#39;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cid_path</span><span class="p">,</span> <span class="n">cell_ids</span><span class="p">)</span></div>


<div class="viewcode-block" id="SegmentationRun.load_cell_ids">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.SegmentationRun.load_cell_ids">[docs]</a>
    <span class="k">def</span> <span class="nf">load_cell_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">cid_path</span><span class="o">.</span><span class="n">exists</span><span class="p">()</span>
        <span class="n">cell_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cid_path</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cell_ids</span></div>


<div class="viewcode-block" id="SegmentationRun.save_cbg">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.SegmentationRun.save_cbg">[docs]</a>
    <span class="k">def</span> <span class="nf">save_cbg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell_by_gene</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">overwrite</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">cbg_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">FileExistsError</span><span class="p">(</span><span class="s1">&#39;Cell by gene already saved and overwriting is not enabled.&#39;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">cell_by_gene</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cbg_path</span><span class="p">)</span></div>


<div class="viewcode-block" id="SegmentationRun.load_cbg">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.SegmentationRun.load_cbg">[docs]</a>
    <span class="k">def</span> <span class="nf">load_cbg</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">cbg_path</span><span class="o">.</span><span class="n">exists</span><span class="p">()</span>
        <span class="n">cell_by_gene</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">read_h5ad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cbg_path</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cell_by_gene</span></div>


<div class="viewcode-block" id="SegmentationRun.load_spot_table">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.SegmentationRun.load_spot_table">[docs]</a>
    <span class="k">def</span> <span class="nf">load_spot_table</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">load_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_load_func</span><span class="p">()</span>
        <span class="n">load_args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_load_args</span><span class="p">()</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">load_func</span><span class="p">(</span><span class="o">**</span><span class="n">load_args</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subrgn</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">subrgn</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">get_image</span><span class="p">(</span><span class="n">channel</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">subrgn</span><span class="p">)</span><span class="o">.</span><span class="n">bounds</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">subrgn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subrgn</span> 

        <span class="n">subtable</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">get_subregion</span><span class="p">(</span><span class="n">xlim</span><span class="o">=</span><span class="n">subrgn</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ylim</span><span class="o">=</span><span class="n">subrgn</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">subtable</span></div>


<div class="viewcode-block" id="SegmentationRun.run">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.SegmentationRun.run">[docs]</a>
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">use_prod_cids</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">suffix</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">clean_up</span><span class="p">:</span> <span class="nb">str</span><span class="o">|</span><span class="nb">bool</span><span class="o">|</span><span class="kc">None</span><span class="o">=</span><span class="s1">&#39;all_ints&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Run all steps to perform tiled segmentation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        use_prod_cids: bool, optional</span>
<span class="sd">            If True, generate production cell ids and use them to index cells</span>
<span class="sd">            in the cell by gene table. Default True.</span>

<span class="sd">        prefix: str, optional</span>
<span class="sd">            The string to prepend to all production cell ids.</span>

<span class="sd">        suffix: str, optional</span>
<span class="sd">            The string to append to all production cell ids.</span>

<span class="sd">        overwrite: bool, optional</span>
<span class="sd">            Whether to allow overwriting of output files. Default False.</span>
<span class="sd">            </span>
<span class="sd">        clean_up: str, bool, None, optional</span>
<span class="sd">            Whether or not to clean up intermediate files after segmentation</span>
<span class="sd">            Accepts: &#39;all_ints&#39;, &#39;seg_ints&#39;, &#39;polygon_ints&#39;, &#39;none&#39;, True, False, None</span>
<span class="sd">            Default: cleans up all intermediate files.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SpotTable</span>
<span class="sd">            The segmented spot table.</span>

<span class="sd">        AnnData</span>
<span class="sd">            The cell by gene table.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># update and save run metadata in case user updated parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_metadata</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_metadata</span><span class="p">(</span><span class="n">overwrite</span><span class="p">)</span>

        <span class="c1"># load the spot table corresponding to the segmentation region</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spot_table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_spot_table</span><span class="p">()</span>

        <span class="c1"># run all steps in sequence</span>
        <span class="n">tiles</span><span class="p">,</span> <span class="n">regions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_seg_region</span><span class="p">(</span><span class="n">overwrite</span><span class="p">)</span>
        <span class="n">seg_run_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_seg_run_spec</span><span class="p">(</span><span class="n">regions</span><span class="o">=</span><span class="n">regions</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">,</span> <span class="n">result_files</span><span class="o">=</span><span class="kc">False</span> <span class="k">if</span> <span class="n">clean_up</span> <span class="k">else</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">jobs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">submit_jobs</span><span class="p">(</span><span class="s1">&#39;segmentation&#39;</span><span class="p">,</span> <span class="n">seg_run_spec</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">)</span>
        <span class="n">cell_ids</span><span class="p">,</span> <span class="n">merge_results</span><span class="p">,</span> <span class="n">seg_skipped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_segmented_tiles</span><span class="p">(</span><span class="n">run_spec</span><span class="o">=</span><span class="n">seg_run_spec</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">)</span>
        <span class="n">polygon_run_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_polygon_run_spec</span><span class="p">(</span><span class="n">overwrite</span><span class="p">)</span>
        <span class="n">jobs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">submit_jobs</span><span class="p">(</span><span class="s1">&#39;cell_polygons&#39;</span><span class="p">,</span> <span class="n">polygon_run_spec</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">)</span>
        <span class="n">cell_polygons</span><span class="p">,</span> <span class="n">cell_polygons_skipped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_cell_polygons</span><span class="p">(</span><span class="n">run_spec</span><span class="o">=</span><span class="n">polygon_run_spec</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">)</span>
        <span class="n">cell_by_gene</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_cell_by_gene</span><span class="p">(</span><span class="n">use_prod_cids</span><span class="o">=</span><span class="n">use_prod_cids</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="n">suffix</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">clean_up</span><span class="p">:</span>
            <span class="n">clean_up</span> <span class="o">=</span> <span class="s1">&#39;all_ints&#39;</span> <span class="k">if</span> <span class="n">clean_up</span> <span class="o">==</span> <span class="kc">True</span> <span class="k">else</span> <span class="n">clean_up</span> <span class="c1"># If the user decides to input true we&#39;ll just set that to all ints</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clean_up</span><span class="p">(</span><span class="n">clean_up</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spot_table</span><span class="p">,</span> <span class="n">cell_by_gene</span></div>


<div class="viewcode-block" id="SegmentationRun.resume">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.SegmentationRun.resume">[docs]</a>
    <span class="k">def</span> <span class="nf">resume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Resuming from previous segmentation not implemented.&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="SegmentationRun.load_results">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.SegmentationRun.load_results">[docs]</a>
    <span class="k">def</span> <span class="nf">load_results</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load the results of a finished segmentation.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spot_table</span><span class="o">.</span><span class="n">cell_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_cell_ids</span><span class="p">()</span>
        <span class="n">cell_by_gene</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_cbg</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spot_table</span><span class="p">,</span> <span class="n">cell_by_gene</span></div>


<div class="viewcode-block" id="SegmentationRun.track_job_progress">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.SegmentationRun.track_job_progress">[docs]</a>
    <span class="k">def</span> <span class="nf">track_job_progress</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jobs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Track progress of hpc jobs. until all jobs have ended</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Job IDs: </span><span class="si">{</span><span class="n">jobs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">job_id</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="n">jobs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">job_id</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">jobs</span><span class="p">))</span> <span class="k">as</span> <span class="n">pbar</span><span class="p">:</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="n">jobs</span><span class="o">.</span><span class="n">is_done</span><span class="p">():</span>
                <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>
                <span class="n">n_done</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="mi">1</span> <span class="k">for</span> <span class="n">job</span> <span class="ow">in</span> <span class="n">jobs</span><span class="o">.</span><span class="n">jobs</span> <span class="k">if</span> <span class="n">job</span><span class="o">.</span><span class="n">is_done</span><span class="p">()]))</span>
                <span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">n_done</span> <span class="o">-</span> <span class="n">pbar</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([</span><span class="n">job</span><span class="o">.</span><span class="n">state</span><span class="p">()</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="s2">&quot;COMPLETED&quot;</span> <span class="k">for</span> <span class="n">job</span> <span class="ow">in</span> <span class="n">jobs</span><span class="o">.</span><span class="n">jobs</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;All jobs failed. Please check error logs in </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="s2">&quot;hpc-jobs&quot;</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="SegmentationRun.tile_seg_region">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.SegmentationRun.tile_seg_region">[docs]</a>
    <span class="k">def</span> <span class="nf">tile_seg_region</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_tile_size</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">overlap</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">30</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Tiling segmentation region...&#39;</span><span class="p">)</span>
        <span class="n">subtable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spot_table</span>

        <span class="n">tiles</span> <span class="o">=</span> <span class="n">subtable</span><span class="o">.</span><span class="n">grid_tiles</span><span class="p">(</span><span class="n">max_tile_size</span><span class="o">=</span><span class="n">max_tile_size</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="n">overlap</span><span class="p">)</span>
        <span class="n">regions</span> <span class="o">=</span> <span class="p">[</span><span class="n">tile</span><span class="o">.</span><span class="n">parent_region</span> <span class="k">for</span> <span class="n">tile</span> <span class="ow">in</span> <span class="n">tiles</span><span class="p">]</span>

        <span class="c1"># save regions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_regions</span><span class="p">(</span><span class="n">regions</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">tiles</span><span class="p">,</span> <span class="n">regions</span></div>


<div class="viewcode-block" id="SegmentationRun.get_seg_run_spec">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.SegmentationRun.get_seg_run_spec">[docs]</a>
    <span class="k">def</span> <span class="nf">get_seg_run_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">regions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">result_files</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">regions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">regions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_regions</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tile_save_path</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Generating segmentation spec for </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">regions</span><span class="p">)</span><span class="si">}</span><span class="s2"> tiles...&quot;</span><span class="p">)</span>
        <span class="n">run_spec</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">region</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">regions</span><span class="p">):</span>
            <span class="n">run_spec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">run_segmentation</span><span class="p">,</span>
                <span class="p">(),</span>
                <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">load_func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_load_func</span><span class="p">(),</span>
                    <span class="n">load_args</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_load_args</span><span class="p">(),</span>
                    <span class="n">subregion</span><span class="o">=</span><span class="n">region</span><span class="p">,</span>
                    <span class="n">method_class</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">seg_method</span><span class="p">,</span>
                    <span class="n">method_args</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">seg_opts</span><span class="p">,</span>
                    <span class="n">result_file</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_save_path</span><span class="o">.</span><span class="n">as_posix</span><span class="p">()</span><span class="si">}</span><span class="s1">/&#39;</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;segmentation_result_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">.pkl&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">result_files</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">cell_id_file</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_save_path</span><span class="o">.</span><span class="n">as_posix</span><span class="p">()</span><span class="si">}</span><span class="s1">/&#39;</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;segmentation_result_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">.npy&#39;</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="p">)</span>
        
        <span class="c1"># save run_spec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_run_spec</span><span class="p">(</span><span class="n">run_spec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">seg_run_spec_path</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">run_spec</span></div>


    <span class="k">def</span> <span class="nf">_check_overwrite_dir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">overwrite_dir</span><span class="p">,</span> <span class="n">overwrite_file</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Helpeer function to check whether to overwrite files in a directory&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">overwrite</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">overwrite_dir</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">overwrite_file</span><span class="p">)):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Deleting saved </span><span class="si">{</span><span class="n">overwrite_file</span><span class="si">}</span><span class="s1"> files from previous run...&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">tile_path</span> <span class="ow">in</span> <span class="n">overwrite_dir</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">overwrite_file</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">tile_path</span><span class="o">.</span><span class="n">is_file</span><span class="p">():</span>
                    <span class="n">tile_path</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">overwrite</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">overwrite_dir</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">overwrite_file</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">FileExistsError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Saved </span><span class="si">{</span><span class="n">overwrite_file</span><span class="si">}</span><span class="s1"> files detected in directory and overwriting is disabled.&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="SegmentationRun.submit_jobs">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.SegmentationRun.submit_jobs">[docs]</a>
    <span class="k">def</span> <span class="nf">submit_jobs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">job_type</span><span class="p">,</span> <span class="n">run_spec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># Check job type and set variables</span>
        <span class="k">if</span> <span class="n">job_type</span> <span class="o">==</span> <span class="s1">&#39;segmentation&#39;</span><span class="p">:</span>
            <span class="n">run_spec_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seg_run_spec_path</span> 
            <span class="n">hpc_opts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seg_hpc_opts</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_overwrite_dir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_save_path</span><span class="p">,</span> <span class="s1">&#39;segmentation_result*&#39;</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">)</span>
            <span class="n">default_mem</span> <span class="o">=</span> <span class="s2">&quot;20G&quot;</span>
            <span class="n">gpus_per_node</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">status_str</span> <span class="o">=</span> <span class="s1">&#39;Segmenting tiles...&#39;</span>
        <span class="k">elif</span> <span class="n">job_type</span> <span class="o">==</span> <span class="s1">&#39;cell_polygons&#39;</span><span class="p">:</span>
            <span class="n">run_spec_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon_run_spec_path</span>
            <span class="n">hpc_opts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon_hpc_opts</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_overwrite_dir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polygon_save_path</span><span class="p">,</span> <span class="s1">&#39;cell_polygons_subset_*&#39;</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">)</span>
            <span class="n">default_mem</span> <span class="o">=</span> <span class="s2">&quot;10G&quot;</span>
            <span class="n">gpus_per_node</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">status_str</span> <span class="o">=</span> <span class="s1">&#39;Calculating cell polygons...&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid job type.&#39;</span><span class="p">)</span> 
        
        <span class="k">if</span> <span class="n">run_spec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">run_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_run_spec</span><span class="p">(</span><span class="n">run_spec_path</span><span class="p">)</span>
        
        <span class="n">job_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="s1">&#39;hpc-jobs&#39;</span><span class="p">)</span>
        <span class="n">job_path</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">hpc_opts</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;job_path&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">job_path</span><span class="o">.</span><span class="n">as_posix</span><span class="p">()</span><span class="si">}</span><span class="s1">/&#39;</span><span class="p">})</span>

        <span class="n">hpc_config</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;run_spec&#39;</span><span class="p">:</span> <span class="n">run_spec</span><span class="p">,</span>
            <span class="s1">&#39;conda_env&#39;</span><span class="p">:</span> <span class="n">hpc_opts</span><span class="p">[</span><span class="s1">&#39;conda_env&#39;</span><span class="p">],</span>
            <span class="s1">&#39;hpc_host&#39;</span><span class="p">:</span> <span class="n">hpc_opts</span><span class="p">[</span><span class="s1">&#39;hpc_host&#39;</span><span class="p">],</span>
            <span class="s1">&#39;job_path&#39;</span><span class="p">:</span> <span class="n">job_path</span><span class="p">,</span>
            <span class="s1">&#39;partition&#39;</span><span class="p">:</span> <span class="s1">&#39;celltypes&#39;</span><span class="p">,</span>
            <span class="s1">&#39;job_name&#39;</span><span class="p">:</span> <span class="n">job_type</span><span class="p">,</span>
            <span class="s1">&#39;nodes&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="s1">&#39;ntasks&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="s1">&#39;array&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;0-</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">run_spec</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="s1">&#39;mincpus&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="s1">&#39;gpus_per_node&#39;</span><span class="p">:</span> <span class="n">gpus_per_node</span><span class="p">,</span>
            <span class="s1">&#39;mem&#39;</span><span class="p">:</span> <span class="n">default_mem</span><span class="p">,</span>
            <span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="s1">&#39;0:30:00&#39;</span><span class="p">,</span>
            <span class="s1">&#39;mail_user&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">hpc_config</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">**</span><span class="n">hpc_opts</span><span class="p">)</span>
        <span class="n">jobs</span> <span class="o">=</span> <span class="n">run_slurm_func</span><span class="p">(</span><span class="o">**</span><span class="n">hpc_config</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">status_str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">track_job_progress</span><span class="p">(</span><span class="n">jobs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">jobs</span></div>


<div class="viewcode-block" id="SegmentationRun.merge_segmented_tiles">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.SegmentationRun.merge_segmented_tiles">[docs]</a>
    <span class="k">def</span> <span class="nf">merge_segmented_tiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_spec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">run_spec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">run_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_run_spec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seg_run_spec_path</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Merging tiles...&#39;</span><span class="p">)</span>
        <span class="c1"># Merging updates the spot table cell_ids in place</span>
        <span class="n">cell_ids</span><span class="p">,</span> <span class="n">merge_results</span><span class="p">,</span> <span class="n">skipped</span> <span class="o">=</span> <span class="n">merge_segmentation_results</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spot_table</span><span class="p">,</span> <span class="n">run_spec</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">run_spec</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">skipped</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;All tiles were skipped, check error logs.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">skipped</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: Some tiles were skipped.&#39;</span><span class="p">)</span>

        <span class="c1"># save cell_ids</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_cell_ids</span><span class="p">(</span><span class="n">cell_ids</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cell_ids</span><span class="p">,</span> <span class="n">merge_results</span><span class="p">,</span> <span class="n">skipped</span></div>


<div class="viewcode-block" id="SegmentationRun.get_polygon_run_spec">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.SegmentationRun.get_polygon_run_spec">[docs]</a>
    <span class="k">def</span> <span class="nf">get_polygon_run_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Generates a cell polygon run spec for running cell polygon jobs on the hpc &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polygon_save_path</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">overwrite</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polygon_save_path</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">&#39;cell_id_subset_*.npy&#39;</span><span class="p">)):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Deleting save id subsets from previous run...&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">tile_path</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_save_path</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">&#39;cell_id_subset_*.npy&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">tile_path</span><span class="o">.</span><span class="n">is_file</span><span class="p">():</span>
                    <span class="n">tile_path</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">overwrite</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polygon_save_path</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">&#39;cell_id_subset_*.npy&#39;</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Saved id subsets detected in directory and overwriting is disabled.&#39;</span><span class="p">)</span>

        <span class="c1"># Find all the cell ids</span>
        <span class="n">unique_cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spot_table</span><span class="o">.</span><span class="n">cell_ids</span><span class="p">)</span>
        <span class="n">unique_cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">unique_cells</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">unique_cells</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">unique_cells</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)))</span>
        <span class="n">num_cells</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_cells</span><span class="p">)</span>

        <span class="c1"># list of tuples assigning cells to jobs</span>
        <span class="k">if</span> <span class="s1">&#39;num_jobs&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon_hpc_opts</span><span class="p">:</span>
            <span class="n">num_jobs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon_hpc_opts</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;num_jobs&#39;</span><span class="p">)</span>
            <span class="n">row_list</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span> <span class="o">*</span> <span class="n">num_cells</span> <span class="o">//</span> <span class="n">num_jobs</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_cells</span> <span class="o">//</span> <span class="n">num_jobs</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_jobs</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="s1">&#39;num_cells_per_job&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon_hpc_opts</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">math</span>
            <span class="n">num_cells_per_job</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon_hpc_opts</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;num_cells_per_job&#39;</span><span class="p">)</span>
            <span class="n">row_list</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span> <span class="o">*</span> <span class="n">num_cells_per_job</span><span class="p">,</span> <span class="nb">min</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_cells_per_job</span><span class="p">,</span> <span class="n">num_cells</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">num_cells</span> <span class="o">/</span> <span class="n">num_cells_per_job</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_jobs</span> <span class="o">=</span> <span class="mi">100</span> <span class="c1"># default to 100 jobs</span>
            <span class="n">row_list</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span> <span class="o">*</span> <span class="n">num_cells</span> <span class="o">//</span> <span class="n">num_jobs</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_cells</span> <span class="o">//</span> <span class="n">num_jobs</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_jobs</span><span class="p">)]</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Generating cell polygon spec for </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">row_list</span><span class="p">)</span><span class="si">}</span><span class="s2"> jobs...&quot;</span><span class="p">)</span>
        <span class="n">run_spec</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">start_idx</span><span class="p">,</span> <span class="n">end_idx</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row_list</span><span class="p">):</span>
            <span class="c1"># Save an input file with the cell IDs to calculate for each job</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polygon_save_path</span> <span class="o">/</span> <span class="sa">f</span><span class="s1">&#39;cell_id_subset_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">.npy&#39;</span><span class="p">,</span> <span class="n">unique_cells</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">])</span>
            
            <span class="c1"># run_spec[i] = (function, args, kwargs)</span>
            <span class="n">run_spec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">sis</span><span class="o">.</span><span class="n">spot_table</span><span class="o">.</span><span class="n">run_cell_polygon_calculation</span><span class="p">,</span>
                <span class="p">(),</span>
                <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">load_func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_load_func</span><span class="p">(),</span>
                    <span class="n">load_args</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_load_args</span><span class="p">(),</span>
                    <span class="n">subregion</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">subrgn</span><span class="p">,</span>
                    <span class="n">cell_id_file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cid_path</span><span class="p">,</span>
                    <span class="n">cell_subset_file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">polygon_save_path</span> <span class="o">/</span> <span class="sa">f</span><span class="s1">&#39;cell_id_subset_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">.npy&#39;</span><span class="p">,</span>
                    <span class="n">result_file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">polygon_save_path</span> <span class="o">/</span> <span class="sa">f</span><span class="s1">&#39;cell_polygons_subset_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">polygon_opts</span><span class="p">[</span><span class="s2">&quot;save_file_extension&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
                    <span class="n">alpha_inv_coeff</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">polygon_opts</span><span class="p">[</span><span class="s1">&#39;alpha_inv_coeff&#39;</span><span class="p">],</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">save_run_spec</span><span class="p">(</span><span class="n">run_spec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon_run_spec_path</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">run_spec</span></div>


<div class="viewcode-block" id="SegmentationRun.merge_cell_polygons">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.SegmentationRun.merge_cell_polygons">[docs]</a>
    <span class="k">def</span> <span class="nf">merge_cell_polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_spec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">run_spec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">run_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_run_spec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polygon_run_spec_path</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Merging cell polygons...&#39;</span><span class="p">)</span>
        <span class="n">skipped</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">area_spec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tqdm</span><span class="p">(</span><span class="n">run_spec</span><span class="o">.</span><span class="n">values</span><span class="p">())):</span>
            <span class="n">result_file</span> <span class="o">=</span> <span class="n">area_spec</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s1">&#39;result_file&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">result_file</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping tile </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> : no result file generated&quot;</span><span class="p">)</span>
                <span class="n">skipped</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">spot_table</span><span class="o">.</span><span class="n">load_cell_polygons</span><span class="p">(</span><span class="n">result_file</span><span class="p">,</span> <span class="n">reset_cache</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">disable_tqdm</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># The reset_cache=False is important to allow reading in the various cell subsets without overwriting</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">run_spec</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">skipped</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;All tiles were skipped, check error logs.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">skipped</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: Some tiles were skipped.&#39;</span><span class="p">)</span>

        <span class="c1"># save polygons</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">overwrite</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span> <span class="o">/</span> <span class="p">(</span><span class="sa">f</span><span class="s1">&#39;cell_polygons.</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">polygon_opts</span><span class="p">[</span><span class="s2">&quot;save_file_extension&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">FileExistsError</span><span class="p">(</span><span class="s1">&#39;cell polygons already saved and overwriting is not enabled.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spot_table</span><span class="o">.</span><span class="n">save_cell_polygons</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span> <span class="o">/</span> <span class="sa">f</span><span class="s1">&#39;cell_polygons.</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">polygon_opts</span><span class="p">[</span><span class="s2">&quot;save_file_extension&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spot_table</span><span class="o">.</span><span class="n">cell_polygons</span><span class="p">,</span> <span class="n">skipped</span></div>

    
    
<div class="viewcode-block" id="SegmentationRun.create_cell_by_gene">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.SegmentationRun.create_cell_by_gene">[docs]</a>
    <span class="k">def</span> <span class="nf">create_cell_by_gene</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">remove_bg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">use_prod_cids</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create and save a cell by gene file in Anndata format using </span>
<span class="sd">        the attached spot table.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">use_prod_cids</span> <span class="ow">and</span> <span class="p">(</span><span class="n">prefix</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span> <span class="ow">or</span> <span class="n">suffix</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: Prefix and/or suffix have been set, but production cell ids are not being used.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">use_prod_cids</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spot_table</span><span class="o">.</span><span class="n">generate_production_cell_ids</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="n">suffix</span><span class="p">)</span>

        <span class="n">subtable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spot_table</span><span class="o">.</span><span class="n">filter_cells</span><span class="p">(</span><span class="n">real_cells</span><span class="o">=</span><span class="n">remove_bg</span><span class="p">)</span> <span class="k">if</span> <span class="n">remove_bg</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">spot_table</span>

        <span class="n">cell_by_gene</span> <span class="o">=</span> <span class="n">subtable</span><span class="o">.</span><span class="n">cell_by_gene_anndata</span><span class="p">(</span><span class="n">use_both_ids</span><span class="o">=</span><span class="n">use_prod_cids</span><span class="p">)</span>
        
        <span class="c1"># Calculate cell volumes to add to cell by gene</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Calculating cell volumes...&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">subtable</span><span class="o">.</span><span class="n">cell_polygons</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">subtable</span><span class="o">.</span><span class="n">cell_polygons</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Default to np.nan if no cell polygons</span>
            <span class="n">cell_feature_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">cell_by_gene</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="n">cell_feature_df</span><span class="p">[[</span><span class="s1">&#39;volume&#39;</span><span class="p">,</span> <span class="s1">&#39;area&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cell_feature_df</span> <span class="o">=</span> <span class="n">subtable</span><span class="o">.</span><span class="n">get_cell_features</span><span class="p">(</span><span class="n">use_both_ids</span><span class="o">=</span><span class="n">use_prod_cids</span><span class="p">)</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;production_cell_id&#39;</span> <span class="k">if</span> <span class="n">use_prod_cids</span> <span class="k">else</span> <span class="s1">&#39;cell_id&#39;</span><span class="p">)</span>
        <span class="n">cell_by_gene</span><span class="o">.</span><span class="n">obs</span> <span class="o">=</span> <span class="n">cell_by_gene</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">cell_feature_df</span><span class="p">[[</span><span class="s1">&#39;volume&#39;</span><span class="p">,</span> <span class="s1">&#39;area&#39;</span><span class="p">]],</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">left_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">right_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">save_cbg</span><span class="p">(</span><span class="n">cell_by_gene</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cell_by_gene</span></div>

        
<div class="viewcode-block" id="SegmentationRun.clean_up">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.SegmentationRun.clean_up">[docs]</a>
    <span class="k">def</span> <span class="nf">clean_up</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;all_ints&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Clean up intermediate files after segmentation and polygon generation is complete</span>

<span class="sd">        Args:</span>
<span class="sd">            mode (string, optional): Can be &#39;all_ints&#39;, &#39;seg_ints&#39;, &#39;polygon_ints&#39;, or &#39;none&#39; depending on desired clean up. Defaults to &#39;all_ints&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;all_ints&#39;</span><span class="p">,</span> <span class="s1">&#39;seg_ints&#39;</span><span class="p">,</span> <span class="s1">&#39;polygon_ints&#39;</span><span class="p">,</span> <span class="s1">&#39;none&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid clean up mode&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;all_ints&quot;</span> <span class="ow">or</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;seg_ints&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">file_path</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_save_path</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">):</span>
                <span class="n">file_path</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tile_save_path</span><span class="o">.</span><span class="n">rmdir</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;all_ints&quot;</span> <span class="ow">or</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;polygon_ints&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">file_path</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon_save_path</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">):</span>
                <span class="n">file_path</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">polygon_save_path</span><span class="o">.</span><span class="n">rmdir</span><span class="p">()</span></div>


<div class="viewcode-block" id="SegmentationRun.from_spatial_dataset">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.SegmentationRun.from_spatial_dataset">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_spatial_dataset</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">sp_dataset</span><span class="p">,</span> <span class="n">output_dir</span><span class="p">,</span> <span class="n">subrgn</span><span class="p">,</span> <span class="n">seg_method</span><span class="p">,</span> <span class="n">seg_opts</span><span class="p">,</span> <span class="n">hpc_opts</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Alternate constructor to load from a SpatialDataset&quot;&quot;&quot;</span>
        <span class="n">image_path</span> <span class="o">=</span> <span class="n">sp_dataset</span><span class="o">.</span><span class="n">images_path</span>
        <span class="n">csv_file</span> <span class="o">=</span> <span class="n">sp_dataset</span><span class="o">.</span><span class="n">detected_transcripts_file</span>
        <span class="n">cache_file</span> <span class="o">=</span> <span class="n">sp_dataset</span><span class="o">.</span><span class="n">detected_transcripts_cache</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">csv_file</span><span class="p">,</span> <span class="n">image_path</span><span class="p">,</span> <span class="n">output_dir</span><span class="p">,</span> <span class="n">cache_file</span><span class="p">,</span> <span class="n">subrgn</span><span class="p">,</span> <span class="n">seg_method</span><span class="p">,</span> <span class="n">seg_opts</span><span class="p">,</span> <span class="n">hpc_opts</span><span class="p">)</span></div>


<div class="viewcode-block" id="SegmentationRun.from_json">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.SegmentationRun.from_json">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_json</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">json_file</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load a run from a json file&quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">json_file</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">config</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="n">seg_method_name</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;seg_method&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">seg_method_name</span> <span class="o">==</span> <span class="s1">&#39;CellposeSegmentationMethod&#39;</span><span class="p">:</span>
            <span class="n">config</span><span class="p">[</span><span class="s1">&#39;seg_method&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sis</span><span class="o">.</span><span class="n">segmentation</span><span class="o">.</span><span class="n">CellposeSegmentationMethod</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Segmentation method </span><span class="si">{</span><span class="n">seg_method_name</span><span class="si">}</span><span class="s1"> not implemented.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;subrgn&#39;</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">config</span><span class="p">[</span><span class="s1">&#39;subrgn&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;subrgn&#39;</span><span class="p">]])</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">config</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="MerscopeSegmentationRun">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.MerscopeSegmentationRun">[docs]</a>
<span class="k">class</span> <span class="nc">MerscopeSegmentationRun</span><span class="p">(</span><span class="n">SegmentationRun</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">dt_file</span><span class="p">:</span> <span class="n">Path</span><span class="o">|</span><span class="nb">str</span><span class="p">,</span>
            <span class="n">image_path</span><span class="p">:</span> <span class="n">Path</span><span class="o">|</span><span class="nb">str</span><span class="p">,</span>
            <span class="n">output_dir</span><span class="p">:</span> <span class="n">Path</span><span class="o">|</span><span class="nb">str</span><span class="p">,</span>
            <span class="n">dt_cache</span><span class="p">:</span> <span class="n">Path</span><span class="o">|</span><span class="nb">str</span><span class="o">|</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">subrgn</span><span class="p">:</span> <span class="nb">str</span><span class="o">|</span><span class="nb">tuple</span><span class="p">,</span>
            <span class="n">seg_method</span><span class="p">:</span> <span class="n">SegmentationMethod</span><span class="p">,</span>
            <span class="n">seg_opts</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
            <span class="n">polygon_opts</span><span class="p">:</span> <span class="nb">dict</span><span class="o">|</span><span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">seg_hpc_opts</span><span class="p">:</span> <span class="nb">dict</span><span class="o">|</span><span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">polygon_hpc_opts</span><span class="p">:</span> <span class="nb">dict</span><span class="o">|</span><span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">hpc_opts</span><span class="p">:</span> <span class="nb">dict</span><span class="o">|</span><span class="kc">None</span><span class="o">=</span><span class="kc">None</span>
            <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">dt_file</span><span class="p">,</span> <span class="n">image_path</span><span class="p">,</span> <span class="n">output_dir</span><span class="p">,</span> <span class="n">dt_cache</span><span class="p">,</span> <span class="n">subrgn</span><span class="p">,</span> <span class="n">seg_method</span><span class="p">,</span> <span class="n">seg_opts</span><span class="p">,</span> <span class="n">polygon_opts</span><span class="p">,</span> <span class="n">seg_hpc_opts</span><span class="o">=</span><span class="n">seg_hpc_opts</span><span class="p">,</span> <span class="n">polygon_hpc_opts</span><span class="o">=</span><span class="n">polygon_hpc_opts</span><span class="p">,</span> <span class="n">hpc_opts</span><span class="o">=</span><span class="n">hpc_opts</span><span class="p">)</span>

<div class="viewcode-block" id="MerscopeSegmentationRun.get_load_func">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.MerscopeSegmentationRun.get_load_func">[docs]</a>
    <span class="k">def</span> <span class="nf">get_load_func</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the function to load a spot table.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SpotTable</span><span class="o">.</span><span class="n">load_merscope</span></div>


<div class="viewcode-block" id="MerscopeSegmentationRun.get_load_args">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.MerscopeSegmentationRun.get_load_args">[docs]</a>
    <span class="k">def</span> <span class="nf">get_load_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get args to pass to loading function (e.g. when submitting jobs to hpc).&quot;&quot;&quot;</span>
        <span class="n">load_args</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;image_path&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_path</span><span class="p">,</span>
                <span class="s1">&#39;csv_file&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">detected_transcripts_file</span><span class="p">,</span>
                <span class="s1">&#39;cache_file&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">detected_transcripts_cache</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">load_args</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Path</span><span class="p">):</span>
                <span class="n">load_args</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">as_posix</span><span class="p">()</span>

        <span class="n">load_args</span><span class="p">[</span><span class="s1">&#39;max_rows&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">load_args</span></div>
</div>



<div class="viewcode-block" id="StereoSeqSegmentationRun">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.StereoSeqSegmentationRun">[docs]</a>
<span class="k">class</span> <span class="nc">StereoSeqSegmentationRun</span><span class="p">(</span><span class="n">SegmentationRun</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">dt_file</span><span class="p">:</span> <span class="n">Path</span><span class="o">|</span><span class="nb">str</span><span class="p">,</span>
            <span class="n">image_path</span><span class="p">:</span> <span class="n">Path</span><span class="o">|</span><span class="nb">str</span><span class="p">,</span>
            <span class="n">output_dir</span><span class="p">:</span> <span class="n">Path</span><span class="o">|</span><span class="nb">str</span><span class="p">,</span>
            <span class="n">dt_cache</span><span class="p">:</span> <span class="n">Path</span><span class="o">|</span><span class="nb">str</span><span class="o">|</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">subrgn</span><span class="p">:</span> <span class="nb">str</span><span class="o">|</span><span class="nb">tuple</span><span class="p">,</span>
            <span class="n">seg_method</span><span class="p">:</span> <span class="n">SegmentationMethod</span><span class="p">,</span>
            <span class="n">seg_opts</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
            <span class="n">polygon_opts</span><span class="p">:</span> <span class="nb">dict</span><span class="o">|</span><span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">seg_hpc_opts</span><span class="p">:</span> <span class="nb">dict</span><span class="o">|</span><span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">polygon_hpc_opts</span><span class="p">:</span> <span class="nb">dict</span><span class="o">|</span><span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">hpc_opts</span><span class="p">:</span> <span class="nb">dict</span><span class="o">|</span><span class="kc">None</span><span class="o">=</span><span class="kc">None</span>
            <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">dt_file</span><span class="p">,</span> <span class="n">image_path</span><span class="p">,</span> <span class="n">output_dir</span><span class="p">,</span> <span class="n">dt_cache</span><span class="p">,</span> <span class="n">subrgn</span><span class="p">,</span> <span class="n">seg_method</span><span class="p">,</span> <span class="n">seg_opts</span><span class="p">,</span> <span class="n">polygon_opts</span><span class="p">,</span> <span class="n">seg_hpc_opts</span><span class="o">=</span><span class="n">seg_hpc_opts</span><span class="p">,</span> <span class="n">polygon_hpc_opts</span><span class="o">=</span><span class="n">polygon_hpc_opts</span><span class="p">,</span> <span class="n">hpc_opts</span><span class="o">=</span><span class="n">hpc_opts</span><span class="p">)</span>

<div class="viewcode-block" id="StereoSeqSegmentationRun.get_load_func">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.StereoSeqSegmentationRun.get_load_func">[docs]</a>
    <span class="k">def</span> <span class="nf">get_load_func</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the function to load a spot table.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SpotTable</span><span class="o">.</span><span class="n">load_stereoseq</span></div>


<div class="viewcode-block" id="StereoSeqSegmentationRun.get_load_args">
<a class="viewcode-back" href="../../sis.html#sis.segmentation.StereoSeqSegmentationRun.get_load_args">[docs]</a>
    <span class="k">def</span> <span class="nf">get_load_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get args to pass to loading function (e.g. when submitting jobs to hpc).&quot;&quot;&quot;</span>
        <span class="n">load_args</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;image_file&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">images_path</span><span class="p">,</span>
                <span class="s1">&#39;gem_file&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">detected_transcripts_file</span><span class="p">,</span>
                <span class="s1">&#39;cache_file&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">detected_transcripts_cache</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">load_args</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Path</span><span class="p">):</span>
                <span class="n">load_args</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">as_posix</span><span class="p">()</span>

        <span class="n">load_args</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;skiprows&#39;</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span> <span class="s1">&#39;image_channel&#39;</span><span class="p">:</span> <span class="s1">&#39;nuclear&#39;</span><span class="p">})</span>

        <span class="k">return</span> <span class="n">load_args</span></div>
</div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">Spots-in-Spaaaaaace!</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, Allen Spatial Analysis Working Group.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
    </div>

    

    
  </body>
</html>